<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Möbius Infinity - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script src="../Three.js"></script>
    <script type="module">
        import {
            noise3D, mouse,
            ColorPalettes, hexToRgb,
            map, smoothstep
        } from '../jazer-background-engine.js';

        const THREE = window.THREE;
        const canvas = document.getElementById('c');

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const palette = ColorPalettes.synthwave;

        // Create Möbius strip geometry
        function createMobiusGeometry(radius, width, segments, twists) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                const t = (i / segments) * Math.PI * 2;

                for (let j = 0; j <= 10; j++) {
                    const s = (j / 10) * 2 - 1;

                    // Möbius strip parametric equations
                    const halfTwist = t * twists / 2;
                    const x = (radius + s * width * Math.cos(halfTwist)) * Math.cos(t);
                    const y = (radius + s * width * Math.cos(halfTwist)) * Math.sin(t);
                    const z = s * width * Math.sin(halfTwist);

                    vertices.push(x, y, z);

                    // Color based on position
                    const colorT = ((t / (Math.PI * 2)) + j / 10) % 1;
                    const colorIdx = Math.floor(colorT * palette.length);
                    const color = new THREE.Color(palette[colorIdx]);
                    colors.push(color.r, color.g, color.b);
                }
            }

            // Create indices for triangles
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < 10; j++) {
                    const a = i * 11 + j;
                    const b = a + 11;
                    const c = a + 1;
                    const d = b + 1;

                    indices.push(a, b, c);
                    indices.push(c, b, d);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            return geometry;
        }

        // Main Möbius strip
        const mobiusGeometry = createMobiusGeometry(3, 0.8, 200, 1);
        const mobiusMaterial = new THREE.MeshStandardMaterial({
            vertexColors: true,
            metalness: 0.7,
            roughness: 0.2,
            side: THREE.DoubleSide,
            emissive: new THREE.Color(0x220033),
            emissiveIntensity: 0.3
        });
        const mobius = new THREE.Mesh(mobiusGeometry, mobiusMaterial);
        scene.add(mobius);

        // Wireframe overlay
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            wireframe: true,
            transparent: true,
            opacity: 0.1
        });
        const wireframe = new THREE.Mesh(mobiusGeometry.clone(), wireframeMaterial);
        scene.add(wireframe);

        // Glowing edge particles
        const edgeParticleCount = 500;
        const edgeParticleGeometry = new THREE.BufferGeometry();
        const edgePositions = new Float32Array(edgeParticleCount * 3);
        const edgeColors = new Float32Array(edgeParticleCount * 3);

        for (let i = 0; i < edgeParticleCount; i++) {
            const t = (i / edgeParticleCount) * Math.PI * 2;
            const edge = Math.random() > 0.5 ? 1 : -1;
            const halfTwist = t * 0.5;

            edgePositions[i * 3] = (3 + edge * 0.8 * Math.cos(halfTwist)) * Math.cos(t);
            edgePositions[i * 3 + 1] = (3 + edge * 0.8 * Math.cos(halfTwist)) * Math.sin(t);
            edgePositions[i * 3 + 2] = edge * 0.8 * Math.sin(halfTwist);

            const color = new THREE.Color(palette[i % palette.length]);
            edgeColors[i * 3] = color.r;
            edgeColors[i * 3 + 1] = color.g;
            edgeColors[i * 3 + 2] = color.b;
        }

        edgeParticleGeometry.setAttribute('position', new THREE.BufferAttribute(edgePositions, 3));
        edgeParticleGeometry.setAttribute('color', new THREE.BufferAttribute(edgeColors, 3));

        const edgeParticleMaterial = new THREE.PointsMaterial({
            size: 0.08,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });

        const edgeParticles = new THREE.Points(edgeParticleGeometry, edgeParticleMaterial);
        scene.add(edgeParticles);

        // Orbiting particles
        const orbitParticleCount = 200;
        const orbitParticleGeometry = new THREE.BufferGeometry();
        const orbitPositions = new Float32Array(orbitParticleCount * 3);
        const orbitData = [];

        for (let i = 0; i < orbitParticleCount; i++) {
            orbitData.push({
                angle: Math.random() * Math.PI * 2,
                radius: 4 + Math.random() * 2,
                height: (Math.random() - 0.5) * 3,
                speed: 0.5 + Math.random() * 0.5,
                phase: Math.random() * Math.PI * 2
            });
        }

        orbitParticleGeometry.setAttribute('position', new THREE.BufferAttribute(orbitPositions, 3));

        const orbitParticleMaterial = new THREE.PointsMaterial({
            size: 0.05,
            color: 0xffffff,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const orbitParticles = new THREE.Points(orbitParticleGeometry, orbitParticleMaterial);
        scene.add(orbitParticles);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
        scene.add(ambientLight);

        const lights = [];
        for (let i = 0; i < 4; i++) {
            const color = new THREE.Color(palette[i]);
            const light = new THREE.PointLight(color, 2, 10);
            lights.push({ light, angle: (i / 4) * Math.PI * 2 });
            scene.add(light);
        }

        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 1 / 60;
            mouse.update();

            // Rotate Möbius strip
            mobius.rotation.x = time * 0.2 + mouse.centeredY * 0.5;
            mobius.rotation.z = time * 0.1 + mouse.centeredX * 0.3;
            wireframe.rotation.copy(mobius.rotation);
            edgeParticles.rotation.copy(mobius.rotation);

            // Animate edge particles along the strip
            const edgePos = edgeParticles.geometry.attributes.position.array;
            for (let i = 0; i < edgeParticleCount; i++) {
                const baseT = (i / edgeParticleCount) * Math.PI * 2;
                const t = baseT + time * 0.5;
                const edge = i % 2 === 0 ? 1 : -1;
                const halfTwist = t * 0.5;
                const wobble = Math.sin(t * 3 + time * 2) * 0.1;

                edgePos[i * 3] = (3 + edge * (0.8 + wobble) * Math.cos(halfTwist)) * Math.cos(t);
                edgePos[i * 3 + 1] = (3 + edge * (0.8 + wobble) * Math.cos(halfTwist)) * Math.sin(t);
                edgePos[i * 3 + 2] = edge * (0.8 + wobble) * Math.sin(halfTwist);
            }
            edgeParticles.geometry.attributes.position.needsUpdate = true;

            // Animate orbit particles
            const orbitPos = orbitParticles.geometry.attributes.position.array;
            for (let i = 0; i < orbitParticleCount; i++) {
                const d = orbitData[i];
                d.angle += d.speed * (1 / 60);

                orbitPos[i * 3] = Math.cos(d.angle) * d.radius;
                orbitPos[i * 3 + 1] = d.height + Math.sin(time * 2 + d.phase) * 0.5;
                orbitPos[i * 3 + 2] = Math.sin(d.angle) * d.radius;
            }
            orbitParticles.geometry.attributes.position.needsUpdate = true;

            // Animate lights
            lights.forEach((l, i) => {
                l.angle += 0.02;
                l.light.position.set(
                    Math.cos(l.angle) * 5,
                    Math.sin(time + i) * 2,
                    Math.sin(l.angle) * 5
                );
                l.light.intensity = 1.5 + Math.sin(time * 2 + i) * 0.5;
            });

            // Camera movement
            camera.position.x = Math.sin(time * 0.1) * 2 + mouse.centeredX * 3;
            camera.position.y = 2 + mouse.centeredY * 2;
            camera.position.z = 8 + Math.cos(time * 0.1) * 2;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>