<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JaZeR Binary Star Tunnel</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: #01010a;
      color: #e4edff;
      min-height: 100vh;
      overflow: hidden;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .label {
      position: fixed;
      top: 2rem;
      right: 2rem;
      font-size: 0.85rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.35);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="effect"></canvas>
  <div class="label">Binary Star Tunnel</div>
  <script type="module">
    import { mouse, noise2D, ColorPalettes } from '../lib/jazer-background-engine.js';

    const canvas = document.getElementById('effect');
    const ctx = canvas.getContext('2d');
    const palette = ColorPalettes.quantum || ColorPalettes.cyberpunk || ColorPalettes.jazer;

    const STAR_COUNT = 900;
    const RING_COUNT = 30;
    const orbitTrail = [];
    const stars = [];
    const rings = [];

    let width = 0;
    let height = 0;
    let lastTime = 0;
    let time = 0;

    class TunnelStar {
      constructor() {
        this.reset();
      }

      reset() {
        this.depth = Math.random();
        this.angle = Math.random() * Math.PI * 2;
        this.radius = 80 + Math.random() * 320;
        this.speed = 0.3 + Math.random() * 0.6;
        this.color = palette[Math.floor(Math.random() * palette.length)] || '#00f5ff';
      }

      tick(dt) {
        this.depth -= dt * this.speed * 0.4;
        if (this.depth <= 0) {
          this.reset();
          this.depth += 1;
        }
      }

      draw() {
        const perspective = 0.2 + Math.pow(1 - this.depth, 2.2);
        const radius = this.radius * perspective;
        const x = width / 2 + Math.cos(this.angle + time * 0.5) * radius + mouse.centeredX * this.depth * 220;
        const y = height / 2 + Math.sin(this.angle + time * 0.35) * radius * 0.6 - this.depth * height * 0.55 + mouse.centeredY * this.depth * 100;
        const size = Math.max(1, perspective * 3);
        const alpha = Math.min(1, perspective * 1.2);
        ctx.fillStyle = `${this.color}${Math.floor(alpha * 200).toString(16).padStart(2, '0')}`;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 8 * perspective;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class TunnelRing {
      constructor(depth) {
        this.reset(depth);
      }

      reset(depth) {
        this.depth = depth;
        this.tilt = (Math.random() - 0.5) * 0.25;
        this.color = palette[Math.floor(Math.random() * palette.length)] || '#00f5ff';
      }

      tick(dt) {
        this.depth -= dt * 0.5;
        if (this.depth <= 0) {
          this.reset(1);
        }
      }

      draw() {
        const perspective = Math.pow(1 - this.depth, 1.4);
        const radius = perspective * Math.max(width, height) * 0.7 + 40;
        const alpha = Math.max(0, 0.35 - this.depth * 0.25);
        ctx.strokeStyle = `${this.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;
        ctx.lineWidth = 1 + perspective * 1.5;
        ctx.beginPath();
        ctx.ellipse(width / 2, height / 2, radius, radius * 0.6, this.tilt, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    function setup() {
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push(new TunnelStar());
      }
      for (let i = 0; i < RING_COUNT; i++) {
        rings.push(new TunnelRing(i / RING_COUNT));
      }
      resize();
      requestAnimationFrame(render);
    }

    function resize() {
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener('resize', resize);

    function render(now) {
      const dt = (now - lastTime) / 1000 || 0;
      lastTime = now;
      time += dt;
      mouse.update();

      ctx.clearRect(0, 0, width, height);
      drawBackground();

      rings.forEach(ring => {
        ring.tick(dt);
        ring.draw();
      });

      stars.forEach(star => {
        star.tick(dt);
        star.draw();
      });

      drawBinarySystem();
      drawScanlines();

      requestAnimationFrame(render);
    }

    function drawBackground() {
      const gradient = ctx.createRadialGradient(width / 2, height * 0.2, 100, width / 2, height / 2, Math.max(width, height));
      gradient.addColorStop(0, '#040414');
      gradient.addColorStop(1, '#000107');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }

    function drawBinarySystem() {
      const orbitRadius = Math.min(width, height) * 0.18;
      const lift = height * 0.08;
      const colors = [palette[0] || '#ff2aff', palette[1] || '#00f5ff'];

      colors.forEach((color, index) => {
        const angle = time * 0.8 + index * Math.PI;
        const x = width / 2 + Math.cos(angle) * orbitRadius + mouse.centeredX * 40;
        const y = height / 2 + Math.sin(angle) * orbitRadius * 0.6 + lift + mouse.centeredY * 30;

        const halo = ctx.createRadialGradient(x, y, 0, x, y, 90);
        halo.addColorStop(0, '#ffffff');
        halo.addColorStop(0.4, color);
        halo.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.beginPath();
        ctx.arc(x, y, 90, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, Math.PI * 2);
        ctx.fill();

        orbitTrail.push({ x, y, color });
      });

      while (orbitTrail.length > 150) {
        orbitTrail.shift();
      }

      orbitTrail.forEach((point, idx) => {
        const alpha = 1 - idx / orbitTrail.length;
        ctx.fillStyle = `${point.color}${Math.floor(alpha * 120).toString(16).padStart(2, '0')}`;
        ctx.beginPath();
        ctx.arc(point.x, point.y, 2 + alpha * 4, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(width / 2, height / 2 + lift, orbitRadius * 2, orbitRadius * 1.2, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawScanlines() {
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#04040a';
      for (let y = 0; y < height; y += 3) {
        ctx.fillRect(0, y, width, 1);
      }
      ctx.restore();

      if (Math.random() < 0.04) {
        const glitchY = Math.random() * height;
        ctx.fillStyle = 'rgba(255,255,255,0.07)';
        ctx.fillRect(0, glitchY, width, 2);
      }
    }

    setup();
  </script>
</body>
</html>
