<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JaZeR Binary Star Tunnel</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: radial-gradient(circle at 50% 10%, #050313, #010108 70%);
      color: #f4f6ff;
      overflow: hidden;
      min-height: 100vh;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    .label {
      position: fixed;
      right: 2rem;
      top: 2rem;
      font-size: 0.8rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.45);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="effectCanvas"></canvas>
  <div class="label">Binary Star Tunnel</div>
  <script type="module">
    import * as THREE from '../lib/Three.js';
    import { mouse } from '../lib/jazer-background-engine.js';

    const canvas = document.getElementById('effectCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x02000a, 1);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x030015, 0.05);

    const camera = new THREE.PerspectiveCamera(58, 1, 0.1, 300);
    camera.position.set(0, 0, 5);

    const pathPoints = [];
    for (let i = 0; i < 40; i++) {
      pathPoints.push(new THREE.Vector3(
        Math.sin(i * 0.25) * 1.5,
        Math.cos(i * 0.2) * 0.8,
        -i * 2
      ));
    }
    const path = new THREE.CatmullRomCurve3(pathPoints);

    const tunnelGeometry = new THREE.TubeGeometry(path, 800, 0.85, 64, false);
    const tunnelMaterial = new THREE.MeshBasicMaterial({
      color: 0x0d1028,
      wireframe: true,
      transparent: true,
      opacity: 0.25
    });
    const tunnelMesh = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
    scene.add(tunnelMesh);

    const tunnelGlowMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 }
      },
      vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: /* glsl */`
        uniform float uTime;
        varying vec2 vUv;
        void main() {
          float glow = sin(vUv.y * 200.0 - uTime * 6.0) * 0.5 + 0.5;
          glow = smoothstep(0.0, 1.0, glow);
          gl_FragColor = vec4(vec3(0.2, 0.6, 1.0) * glow, glow * 0.4);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const tunnelGlow = new THREE.Mesh(tunnelGeometry.clone(), tunnelGlowMaterial);
    scene.add(tunnelGlow);

    const particleCount = 1200;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleOffsets = new Float32Array(particleCount);
    for (let i = 0; i < particleCount; i++) {
      const t = Math.random();
      const point = path.getPointAt(t);
      const tangent = path.getTangentAt(t);
      const normal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0, 1, 0)).normalize();
      normal.applyAxisAngle(tangent, Math.random() * Math.PI * 2);
      const radius = 1.2 + Math.random() * 2.0;
      const pos = point.clone().add(normal.multiplyScalar(radius));
      particlePositions.set([pos.x, pos.y, pos.z], i * 3);
      particleOffsets[i] = Math.random();
    }
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('offset', new THREE.BufferAttribute(particleOffsets, 1));
    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: { uTime: { value: 0 } },
      vertexShader: /* glsl */`
        attribute float offset;
        uniform float uTime;
        varying float vAlpha;
        void main() {
          vec3 pos = position;
          pos.z += mod(-uTime * 25.0 + offset * 200.0, 200.0);
          vAlpha = fract(offset + uTime * 0.1);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = 30.0 / gl_Position.w;
        }
      `,
      fragmentShader: /* glsl */`
        varying float vAlpha;
        void main() {
          float d = length(gl_PointCoord - 0.5);
          float alpha = smoothstep(0.5, 0.0, d) * vAlpha;
          gl_FragColor = vec4(1.0, 0.9, 0.6, alpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const tunnelParticles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(tunnelParticles);

    const binaryGroup = new THREE.Group();
    const primary = new THREE.Mesh(new THREE.SphereGeometry(0.35, 32, 32), new THREE.MeshBasicMaterial({ color: 0xfff6de }));
    const secondary = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), new THREE.MeshBasicMaterial({ color: 0x9dd4ff }));
    binaryGroup.add(primary, secondary);
    scene.add(binaryGroup);

    const orbitTrailGeometry = new THREE.BufferGeometry();
    const orbitTrailCount = 200;
    const orbitPositions = new Float32Array(orbitTrailCount * 3);
    orbitTrailGeometry.setAttribute('position', new THREE.BufferAttribute(orbitPositions, 3));
    const orbitTrailMaterial = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.4
    });
    const orbitTrail = new THREE.Line(orbitTrailGeometry, orbitTrailMaterial);
    scene.add(orbitTrail);

    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0x1c2cf7,
      transparent: true,
      opacity: 0.25
    });
    const orbitalRing = new THREE.Mesh(new THREE.RingGeometry(0.6, 0.9, 64), ringMaterial);
    orbitalRing.rotation.x = Math.PI / 2;
    binaryGroup.add(orbitalRing);

    const clock = new THREE.Clock();

    function resize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resize);
    resize();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();
      mouse.update();

      const t = (elapsed * 0.05) % 1;
      const camPos = path.getPointAt(t);
      const lookAhead = path.getPointAt((t + 0.01) % 1);
      camera.position.copy(camPos);
      camera.position.x += mouse.centeredX * 0.6;
      camera.position.y += mouse.centeredY * 0.4;
      camera.lookAt(lookAhead);

      tunnelGlowMaterial.uniforms.uTime.value = elapsed;
      particleMaterial.uniforms.uTime.value = elapsed;

      const orbitRadius = 0.9;
      primary.position.set(Math.cos(elapsed * 1.5) * orbitRadius, Math.sin(elapsed * 1.5) * 0.4, 0);
      secondary.position.set(Math.cos(elapsed * 1.5 + Math.PI) * orbitRadius, Math.sin(elapsed * 1.5 + Math.PI) * 0.4, 0);

      for (let i = orbitTrailCount - 1; i > 0; i--) {
        orbitPositions[i * 3] = orbitPositions[(i - 1) * 3];
        orbitPositions[i * 3 + 1] = orbitPositions[(i - 1) * 3 + 1];
        orbitPositions[i * 3 + 2] = orbitPositions[(i - 1) * 3 + 2];
      }
      orbitPositions[0] = primary.position.x;
      orbitPositions[1] = primary.position.y;
      orbitPositions[2] = primary.position.z;
      orbitTrailGeometry.attributes.position.needsUpdate = true;

      tunnelMesh.rotation.z = Math.sin(elapsed * 0.1) * 0.05;
      tunnelMesh.rotation.x = Math.sin(elapsed * 0.08) * 0.02;
      tunnelGlow.rotation.copy(tunnelMesh.rotation);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
