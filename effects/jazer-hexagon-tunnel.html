<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neon Hexagon Tunnel - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import {
            noise2D, mouse, Easing,
            ColorPalettes, lerpColor, hexToRgb,
            map, smoothstep, degToRad
        } from '../lib/jazer-background-engine.js';

        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        let W, H, cx, cy;
        let time = 0;

        const palette = ColorPalettes.vapor;
        const hexCount = 60;

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            cx = W / 2;
            cy = H / 2;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function drawHexagon(x, y, radius, rotation) {
            ctx.beginPath();
            for (let i = 0; i <= 6; i++) {
                const angle = rotation + (i / 6) * Math.PI * 2;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        }

        class HexRing {
            constructor(z) {
                this.z = z;
                this.rotation = Math.random() * Math.PI / 3;
                this.rotDir = Math.random() > 0.5 ? 1 : -1;
                this.pulse = Math.random() * Math.PI * 2;
                this.colorPhase = Math.random();
            }

            update(dt) {
                this.z += dt * 6;
                this.rotation += this.rotDir * dt * 0.3;
                this.pulse += dt * 3;
                if (this.z > 25) {
                    this.z = 0.5;
                    this.colorPhase = Math.random();
                }
            }

            draw() {
                if (this.z < 0.3) return;

                const perspective = 1 / this.z;
                const baseRadius = 500 * perspective;
                const pulseRadius = baseRadius * (1 + Math.sin(this.pulse) * 0.1);

                const alpha = smoothstep(0.5, 2, this.z) * smoothstep(25, 18, this.z);
                if (alpha < 0.01) return;

                const colorT = (time * 0.3 + this.colorPhase) % 1;
                const colorIdx = Math.floor(colorT * palette.length);
                const colorNext = (colorIdx + 1) % palette.length;
                const colorFrac = (colorT * palette.length) % 1;
                const color = lerpColor(palette[colorIdx], palette[colorNext], colorFrac);
                const rgb = hexToRgb(color);

                const offsetX = mouse.centeredX * 80 * perspective;
                const offsetY = mouse.centeredY * 80 * perspective;

                ctx.save();
                ctx.translate(cx + offsetX, cy + offsetY);

                // Outer glow
                ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.3})`;
                ctx.lineWidth = Math.max(1, 12 * perspective);
                ctx.shadowColor = color;
                ctx.shadowBlur = 30 * perspective;
                drawHexagon(0, 0, pulseRadius, this.rotation);
                ctx.stroke();

                // Inner bright line
                ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                ctx.lineWidth = Math.max(1, 3 * perspective);
                ctx.shadowBlur = 15 * perspective;
                drawHexagon(0, 0, pulseRadius, this.rotation);
                ctx.stroke();

                // Corner highlights
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                for (let i = 0; i < 6; i++) {
                    const angle = this.rotation + (i / 6) * Math.PI * 2;
                    const px = Math.cos(angle) * pulseRadius;
                    const py = Math.sin(angle) * pulseRadius;
                    ctx.beginPath();
                    ctx.arc(px, py, Math.max(1, 4 * perspective), 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        const hexRings = Array.from({ length: hexCount }, (_, i) => new HexRing(i * 0.4));

        function render() {
            time += 1 / 60;
            mouse.update();

            // Dark fade with color tint
            ctx.fillStyle = 'rgba(5, 0, 15, 0.12)';
            ctx.fillRect(0, 0, W, H);

            // Ambient glow
            const ambientGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H) * 0.5);
            ambientGlow.addColorStop(0, 'rgba(180, 0, 255, 0.03)');
            ambientGlow.addColorStop(0.5, 'rgba(0, 200, 255, 0.02)');
            ambientGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = ambientGlow;
            ctx.fillRect(0, 0, W, H);

            const dt = 1 / 60;

            // Sort and draw back to front
            hexRings.sort((a, b) => b.z - a.z);
            hexRings.forEach(h => { h.update(dt); h.draw(); });

            // Center portal glow
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const portalGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 80);
            portalGlow.addColorStop(0, 'rgba(255, 100, 255, 0.6)');
            portalGlow.addColorStop(0.3, 'rgba(100, 200, 255, 0.3)');
            portalGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = portalGlow;
            ctx.fillRect(cx - 80, cy - 80, 160, 160);
            ctx.restore();

            // Scanlines
            ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
            for (let y = 0; y < H; y += 4) {
                ctx.fillRect(0, y, W, 2);
            }

            // Vignette
            const vig = ctx.createRadialGradient(cx, cy, Math.min(W, H) * 0.3, cx, cy, Math.max(W, H) * 0.7);
            vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vig.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);

            requestAnimationFrame(render);
        }

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(render);
    </script>
</body>

</html>