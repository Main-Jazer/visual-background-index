<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cosmic Nebula Voyage - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script src="../Three.js"></script>
    <script type="module">
        import { noise3D, mouse, smoothstep } from '../jazer-background-engine.js';

        const THREE = window.THREE;
        const canvas = document.getElementById('c');

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const nebulaColors = [
            { color: new THREE.Color(0xff0055), name: 'magenta' },
            { color: new THREE.Color(0x00f5ff), name: 'cyan' },
            { color: new THREE.Color(0xff2aff), name: 'pink' },
            { color: new THREE.Color(0xffd700), name: 'gold' },
            { color: new THREE.Color(0xb37cff), name: 'purple' },
            { color: new THREE.Color(0x39ff14), name: 'lime' }
        ];

        // Volumetric nebula clouds using particles
        const cloudLayers = [];
        const layerCount = 8;

        for (let layer = 0; layer < layerCount; layer++) {
            const cloudParticleCount = 5000;
            const cloudGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(cloudParticleCount * 3);
            const colors = new Float32Array(cloudParticleCount * 3);
            const sizes = new Float32Array(cloudParticleCount);

            const layerColor = nebulaColors[layer % nebulaColors.length].color;

            for (let i = 0; i < cloudParticleCount; i++) {
                // Create blob-like distribution using noise
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 10 + Math.random() * 30;

                positions[i * 3] = Math.cos(theta) * Math.sin(phi) * r;
                positions[i * 3 + 1] = Math.sin(theta) * Math.sin(phi) * r;
                positions[i * 3 + 2] = Math.cos(phi) * r - layer * 30 - 50;

                // Add some color variation
                const colorVariation = 0.3;
                colors[i * 3] = layerColor.r + (Math.random() - 0.5) * colorVariation;
                colors[i * 3 + 1] = layerColor.g + (Math.random() - 0.5) * colorVariation;
                colors[i * 3 + 2] = layerColor.b + (Math.random() - 0.5) * colorVariation;

                sizes[i] = 1 + Math.random() * 3;
            }

            cloudGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            cloudGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            cloudGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const cloudMat = new THREE.PointsMaterial({
                size: 4,
                vertexColors: true,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });

            const cloud = new THREE.Points(cloudGeo, cloudMat);
            cloud.userData = {
                layer: layer,
                speed: 0.05 + layer * 0.02,
                rotationSpeed: 0.0001 + layer * 0.0001
            };

            scene.add(cloud);
            cloudLayers.push(cloud);
        }

        // Bright stars scattered throughout
        const starCount = 3000;
        const starGeo = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);

        for (let i = 0; i < starCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 300;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 300;
            starPositions[i * 3 + 2] = -Math.random() * 300 - 50;

            const starColor = nebulaColors[Math.floor(Math.random() * nebulaColors.length)].color;
            starColors[i * 3] = starColor.r;
            starColors[i * 3 + 1] = starColor.g;
            starColors[i * 3 + 2] = starColor.b;

            starSizes[i] = 0.5 + Math.random() * 2;
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

        const starMat = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // Glowing cosmic dust ribbons
        const ribbonCount = 15;
        const ribbons = [];

        for (let i = 0; i < ribbonCount; i++) {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-40 + Math.random() * 80, -30 + Math.random() * 60, -50 - i * 20),
                new THREE.Vector3(-20 + Math.random() * 40, -15 + Math.random() * 30, -70 - i * 20),
                new THREE.Vector3(20 + Math.random() * 40, 15 + Math.random() * 30, -90 - i * 20),
                new THREE.Vector3(-40 + Math.random() * 80, -30 + Math.random() * 60, -110 - i * 20)
            ]);

            const tubeGeo = new THREE.TubeGeometry(curve, 100, 0.5, 8, false);
            const tubeMat = new THREE.MeshBasicMaterial({
                color: nebulaColors[i % nebulaColors.length].color,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });

            const ribbon = new THREE.Mesh(tubeGeo, tubeMat);
            ribbon.userData = {
                speed: 0.1 + Math.random() * 0.1,
                originalZ: ribbon.position.z
            };

            scene.add(ribbon);
            ribbons.push(ribbon);
        }

        // Energy plasma spheres
        const plasmaSpheres = [];
        for (let i = 0; i < 20; i++) {
            const sphereGeo = new THREE.SphereGeometry(1 + Math.random() * 3, 32, 32);
            const sphereMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: nebulaColors[i % nebulaColors.length].color }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;

                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;

                        vec3 pos = position;
                        float distortion = sin(pos.x * 3.0 + time) *
                                          sin(pos.y * 3.0 + time * 1.3) *
                                          sin(pos.z * 3.0 + time * 0.7) * 0.2;
                        pos += normal * distortion;

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec3 vNormal;
                    varying vec3 vPosition;

                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        float pulse = sin(time * 2.0) * 0.3 + 0.7;
                        vec3 glowColor = color * (fresnel * pulse);
                        gl_FragColor = vec4(glowColor, fresnel * 0.6);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });

            const plasma = new THREE.Mesh(sphereGeo, sphereMat);
            plasma.position.set(
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60,
                -Math.random() * 200 - 50
            );
            plasma.userData = {
                speed: 0.05 + Math.random() * 0.1,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };

            scene.add(plasma);
            plasmaSpheres.push(plasma);
        }

        // Cosmic rays shooting through space
        const rays = [];
        for (let i = 0; i < 30; i++) {
            const rayGeo = new THREE.CylinderGeometry(0.05, 0.05, 50, 8);
            const rayMat = new THREE.MeshBasicMaterial({
                color: nebulaColors[Math.floor(Math.random() * nebulaColors.length)].color,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const ray = new THREE.Mesh(rayGeo, rayMat);
            ray.position.set(
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100,
                -Math.random() * 300
            );
            ray.rotation.x = Math.random() * Math.PI;
            ray.rotation.y = Math.random() * Math.PI;
            ray.rotation.z = Math.random() * Math.PI;

            ray.userData = {
                speed: 1 + Math.random() * 2,
                fadeSpeed: 0.01 + Math.random() * 0.02
            };

            scene.add(ray);
            rays.push(ray);
        }

        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            mouse.update();

            // Move camera forward through nebula
            camera.position.z -= 0.1;

            // Animate nebula cloud layers
            cloudLayers.forEach(cloud => {
                cloud.rotation.y += cloud.userData.rotationSpeed;
                cloud.rotation.z += cloud.userData.rotationSpeed * 0.5;

                // Shift particles with noise
                const pos = cloud.geometry.attributes.position.array;
                for (let i = 0; i < pos.length / 3; i++) {
                    const idx = i * 3;
                    const noiseVal = noise3D(
                        pos[idx] * 0.05,
                        pos[idx + 1] * 0.05,
                        time * 0.1 + cloud.userData.layer
                    );

                    pos[idx] += Math.sin(noiseVal + time) * 0.02;
                    pos[idx + 1] += Math.cos(noiseVal + time) * 0.02;
                }
                cloud.geometry.attributes.position.needsUpdate = true;

                // Loop clouds
                if (camera.position.z < cloud.position.z - 100) {
                    cloud.position.z = camera.position.z - 300;
                }
            });

            // Twinkle stars
            const starSizeArray = stars.geometry.attributes.size.array;
            for (let i = 0; i < starSizeArray.length; i++) {
                starSizeArray[i] = (0.5 + Math.random() * 2) * (1 + Math.sin(time * 5 + i) * 0.3);
            }
            stars.geometry.attributes.size.needsUpdate = true;

            // Move ribbons
            ribbons.forEach(ribbon => {
                ribbon.position.z += ribbon.userData.speed;
                if (ribbon.position.z > camera.position.z + 50) {
                    ribbon.position.z = camera.position.z - 300;
                }
            });

            // Animate plasma spheres
            plasmaSpheres.forEach(plasma => {
                plasma.rotation.y += plasma.userData.rotationSpeed;
                plasma.material.uniforms.time.value = time;
                plasma.position.z += plasma.userData.speed;

                if (plasma.position.z > camera.position.z + 50) {
                    plasma.position.z = camera.position.z - 300;
                    plasma.position.x = (Math.random() - 0.5) * 60;
                    plasma.position.y = (Math.random() - 0.5) * 60;
                }
            });

            // Animate cosmic rays
            rays.forEach(ray => {
                ray.position.z += ray.userData.speed;

                if (ray.position.z > camera.position.z + 100) {
                    ray.position.z = camera.position.z - 300;
                    ray.position.x = (Math.random() - 0.5) * 100;
                    ray.position.y = (Math.random() - 0.5) * 100;
                    ray.material.opacity = 0.6;
                }

                // Fade as approaching
                const dist = ray.position.z - camera.position.z;
                if (dist > 0) {
                    ray.material.opacity = Math.max(0, 0.6 - (dist / 100) * 0.6);
                }
            });

            // Camera sway with mouse
            camera.position.x = mouse.centeredX * 10;
            camera.position.y = mouse.centeredY * 10;
            camera.lookAt(camera.position.x * 0.1, camera.position.y * 0.1, camera.position.z - 100);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>
