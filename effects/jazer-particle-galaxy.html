<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Particle Galaxy - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import { noise3D, mouse, ColorPalettes } from '../lib/jazer-background-engine.js';

        import * as THREE from '../lib/Three.js';
        window.THREE = THREE;
        const canvas = document.getElementById('c');

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Galaxy parameters
        const arms = 4;
        const particleCount = 50000;
        const galaxyRadius = 5;

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        const colorInside = new THREE.Color(0xff0055);
        const colorOutside = new THREE.Color(0x0055ff);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            // Spiral arm distribution
            const radius = Math.random() * galaxyRadius;
            const spinAngle = radius * 2; // Tighter spin near center
            const armAngle = ((i % arms) / arms) * Math.PI * 2;
            const randomOffset = (Math.random() - 0.5) * 0.5 * radius;

            positions[i3] = Math.cos(armAngle + spinAngle) * radius + randomOffset * Math.cos(armAngle);
            positions[i3 + 1] = (Math.random() - 0.5) * 0.3 * (1 - radius / galaxyRadius); // Flatten toward edge
            positions[i3 + 2] = Math.sin(armAngle + spinAngle) * radius + randomOffset * Math.sin(armAngle);

            // Color gradient based on distance
            const mixedColor = colorInside.clone().lerp(colorOutside, radius / galaxyRadius);
            colors[i3] = mixedColor.r;
            colors[i3 + 1] = mixedColor.g;
            colors[i3 + 2] = mixedColor.b;

            sizes[i] = Math.random() * 0.03 + 0.01;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Custom shader for particles
        const galaxyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                pixelRatio: { value: renderer.getPixelRatio() }
            },
            vertexShader: `
        uniform float time;
        uniform float pixelRatio;
        attribute float size;
        attribute vec3 color;
        varying vec3 vColor;
        varying float vDist;
        
        void main() {
          vColor = color;
          
          vec3 pos = position;
          float dist = length(pos.xz);
          vDist = dist;
          
          // Orbital rotation - faster near center
          float rotSpeed = 0.1 + (1.0 - dist/5.0) * 0.3;
          float angle = atan(pos.z, pos.x) + time * rotSpeed;
          pos.x = cos(angle) * dist;
          pos.z = sin(angle) * dist;
          
          // Bobbing motion
          pos.y += sin(time * 2.0 + dist * 3.0) * 0.05;
          
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = size * 300.0 * pixelRatio / -mvPosition.z;
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
            fragmentShader: `
        varying vec3 vColor;
        varying float vDist;
        
        void main() {
          float dist = length(gl_PointCoord - 0.5);
          if (dist > 0.5) discard;
          
          float alpha = 1.0 - dist * 2.0;
          alpha = pow(alpha, 1.5);
          
          // Brighter near center
          float brightness = 1.0 + (1.0 - vDist/5.0) * 0.5;
          
          gl_FragColor = vec4(vColor * brightness, alpha);
        }
      `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const galaxy = new THREE.Points(geometry, galaxyMaterial);
        scene.add(galaxy);

        // Central black hole / core
        const coreGeometry = new THREE.SphereGeometry(0.15, 32, 32);
        const coreMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
            fragmentShader: `
        uniform float time;
        varying vec2 vUv;
        
        void main() {
          float dist = length(vUv - 0.5) * 2.0;
          vec3 color1 = vec3(1.0, 0.0, 0.3);
          vec3 color2 = vec3(0.0, 0.9, 1.0);
          vec3 color = mix(color1, color2, sin(time * 2.0 + dist * 10.0) * 0.5 + 0.5);
          float glow = 1.0 - pow(dist, 0.5);
          gl_FragColor = vec4(color * glow * 2.0, glow);
        }
      `,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(core);

        // Core glow
        const glowGeo = new THREE.SphereGeometry(0.5, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0xff0055,
            transparent: true,
            opacity: 0.1,
            blending: THREE.AdditiveBlending
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        scene.add(glow);

        // Background stars
        const starCount = 2000;
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            starPos[i * 3] = (Math.random() - 0.5) * 100;
            starPos[i * 3 + 1] = (Math.random() - 0.5) * 100;
            starPos[i * 3 + 2] = (Math.random() - 0.5) * 100;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.05,
            transparent: true,
            opacity: 0.6
        });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.008;
            mouse.update();

            // Update shader uniforms
            galaxyMaterial.uniforms.time.value = time;
            coreMaterial.uniforms.time.value = time;

            // Core pulse
            const pulse = 1 + Math.sin(time * 3) * 0.2;
            glow.scale.setScalar(pulse);

            // Camera orbit
            camera.position.x = Math.sin(time * 0.1) * 8 + mouse.centeredX * 3;
            camera.position.y = 4 + mouse.centeredY * 2 + Math.sin(time * 0.15) * 2;
            camera.position.z = Math.cos(time * 0.1) * 8;
            camera.lookAt(0, 0, 0);

            // Rotate stars slowly
            stars.rotation.y += 0.0003;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            galaxyMaterial.uniforms.pixelRatio.value = renderer.getPixelRatio();
        });

        animate();
    </script>
</body>

</html>