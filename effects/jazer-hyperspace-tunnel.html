<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hyperspace Tunnel - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import {
            noise2D, noise3D, mouse, Easing,
            ColorPalettes, cycleColor, hexToRgb,
            map, clamp, smoothstep
        } from '../lib/jazer-background-engine.js';

        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        let W, H, cx, cy;
        let time = 0;

        const palette = ColorPalettes.cyberpunk;
        const lineCount = 120;
        const ringCount = 40;

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            cx = W / 2;
            cy = H / 2;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        class TunnelRing {
            constructor(z) {
                this.z = z;
                this.segments = 8 + Math.floor(Math.random() * 8);
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = (Math.random() - 0.5) * 0.02;
                this.colorOffset = Math.random();
            }

            update(dt) {
                this.z += dt * 8;
                this.rotation += this.rotSpeed;
                if (this.z > 20) {
                    this.z = 0.5;
                    this.colorOffset = Math.random();
                }
            }

            draw() {
                if (this.z < 0.1) return;
                const scale = 1 / this.z;
                const radius = 400 * scale;
                const alpha = smoothstep(0.5, 3, this.z) * smoothstep(20, 10, this.z);

                const color = cycleColor(palette, time * 0.5 + this.colorOffset * 4);
                const rgb = hexToRgb(color);

                ctx.save();
                ctx.translate(cx + mouse.centeredX * 50 * scale, cy + mouse.centeredY * 50 * scale);
                ctx.rotate(this.rotation);
                ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.8})`;
                ctx.lineWidth = Math.max(1, 3 * scale);
                ctx.shadowColor = color;
                ctx.shadowBlur = 20 * scale;

                ctx.beginPath();
                for (let i = 0; i <= this.segments; i++) {
                    const angle = (i / this.segments) * Math.PI * 2;
                    const wobble = noise2D(angle * 2 + this.z, time) * 20 * scale;
                    const r = radius + wobble;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }
        }

        class SpeedLine {
            constructor() {
                this.reset();
            }

            reset() {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 0.4 + 0.1;
                this.x = Math.cos(angle) * dist;
                this.y = Math.sin(angle) * dist;
                this.z = Math.random() * 20;
                this.speed = Math.random() * 5 + 5;
                this.length = Math.random() * 0.5 + 0.2;
                this.colorIdx = Math.floor(Math.random() * palette.length);
            }

            update(dt) {
                this.z += this.speed * dt;
                if (this.z > 20) this.reset();
            }

            draw() {
                const scale1 = 1 / this.z;
                const scale2 = 1 / (this.z + this.length);

                const x1 = cx + this.x * W * scale1 + mouse.centeredX * 100 * scale1;
                const y1 = cy + this.y * H * scale1 + mouse.centeredY * 100 * scale1;
                const x2 = cx + this.x * W * scale2 + mouse.centeredX * 100 * scale2;
                const y2 = cy + this.y * H * scale2 + mouse.centeredY * 100 * scale2;

                const alpha = smoothstep(0.5, 2, this.z) * smoothstep(20, 15, this.z);
                const color = palette[this.colorIdx];
                const rgb = hexToRgb(color);

                const grad = ctx.createLinearGradient(x1, y1, x2, y2);
                grad.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`);
                grad.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);

                ctx.strokeStyle = grad;
                ctx.lineWidth = Math.max(1, 2 * scale1);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        const rings = Array.from({ length: ringCount }, (_, i) => new TunnelRing(i * 0.5));
        const lines = Array.from({ length: lineCount }, () => new SpeedLine());

        function render() {
            time += 1 / 60;
            mouse.update();

            // Trail fade
            ctx.fillStyle = 'rgba(0, 0, 5, 0.15)';
            ctx.fillRect(0, 0, W, H);

            // Central glow
            const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H) * 0.5);
            grd.addColorStop(0, 'rgba(0, 100, 255, 0.05)');
            grd.addColorStop(0.5, 'rgba(100, 0, 255, 0.02)');
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, W, H);

            // Update and draw
            const dt = 1 / 60;

            lines.forEach(l => { l.update(dt); l.draw(); });
            rings.sort((a, b) => b.z - a.z);
            rings.forEach(r => { r.update(dt); r.draw(); });

            // Center bright point
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const centerGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
            centerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            centerGlow.addColorStop(0.2, 'rgba(100, 200, 255, 0.3)');
            centerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = centerGlow;
            ctx.fillRect(cx - 50, cy - 50, 100, 100);
            ctx.restore();

            // Vignette
            const vig = ctx.createRadialGradient(cx, cy, Math.min(W, H) * 0.3, cx, cy, Math.max(W, H) * 0.7);
            vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vig.addColorStop(1, 'rgba(0, 0, 0, 0.7)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);

            requestAnimationFrame(render);
        }

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(render);
    </script>
</body>

</html>