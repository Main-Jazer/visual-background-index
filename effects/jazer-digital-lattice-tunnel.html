<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Digital Lattice Tunnel - JaZeR</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #010206; }
        canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <script type="module">
        import {
            noise2D, mouse, ColorPalettes, lerpColor, hexToRgb,
            map, smoothstep, clamp, fbm2D, fract
        } from '../lib/engine/jazer-background-engine.js';
        import '../lib/engine/jazer-navigation.js';

        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        let W, H, cx, cy;
        let time = 0;

        // Using a palette that has the requested cyberpunk colors
        const palette = ['#00f5ff', '#ff2aff', '#b37cff', '#ffd86b']; // Cyan, Magenta, Purple, Gold
        const ringCount = 50;
        const particleCount = 200;

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            cx = W / 2;
            cy = H / 2;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // Helper to draw a polygon
        function drawPolygon(x, y, radius, sides, rotation) {
            ctx.beginPath();
            for (let i = 0; i <= sides; i++) {
                const angle = rotation + (i / sides) * Math.PI * 2;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
        }

        class TunnelRing {
            constructor(z) { this.respawn(z); }

            respawn(z) {
                this.z = z;
                this.shapeMix = Math.random(); // 0 for circle, 1 for hexagon
                this.colorPhase = Math.random();
            }

            update(dt, speed) {
                this.z -= dt * speed;
                if (this.z < 0.1) {
                    this.respawn(50);
                }
            }

            draw(nextRing) {
                if (this.z < 0.1) return;
                
                const perspective = 300 / this.z;
                
                const wobbleX = noise2D(this.z * 0.1, time * 0.2) * 150;
                const wobbleY = noise2D(this.z * 0.1, time * 0.2 + 100) * 150;
                
                const tunnelTwist = noise2D(this.z * 0.05, time * 0.1) * Math.PI;

                const beat = Math.sin(time * 4 + this.z * 0.2) * 0.5 + 0.5;
                const pulse = 1.0 + smoothstep(0.8, 1.0, beat) * 0.15;
                
                const radius = (10 + this.z * 0.5) * perspective * pulse;
                const alpha = smoothstep(50, 20, this.z) * smoothstep(0.1, 2, this.z);

                if (alpha < 0.01) return;

                const colorT = fract(time * 0.1 + this.colorPhase);
                const colorIdx = Math.floor(colorT * palette.length);
                const colorNext = (colorIdx + 1) % palette.length;
                const color = lerpColor(palette[colorIdx], palette[colorNext], fract(colorT * palette.length));
                const rgb = hexToRgb(color);

                const finalX = cx + wobbleX * perspective;
                const finalY = cy + wobbleY * perspective;

                // --- Draw Ring (Hexagon/Circle) ---
                const sides = this.shapeMix > 0.5 ? 6 : 40; // 40 sides for a smooth circle
                
                ctx.save();
                ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.5})`;
                ctx.lineWidth = Math.max(0.5, 4 * perspective);
                ctx.shadowColor = color;
                ctx.shadowBlur = 15 * perspective;
                
                drawPolygon(finalX, finalY, radius, sides, tunnelTwist);
                ctx.stroke();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = Math.max(0.2, 1 * perspective);
                ctx.shadowBlur = 0;
                ctx.stroke();
                ctx.restore();


                // --- Draw Lattice to next ring ---
                if (nextRing && nextRing.z > this.z) {
                    const nextPerspective = 300 / nextRing.z;
                    const nextWobbleX = noise2D(nextRing.z * 0.1, time * 0.2) * 150;
                    const nextWobbleY = noise2D(nextRing.z * 0.1, time * 0.2 + 100) * 150;
                    const nextTwist = noise2D(nextRing.z * 0.05, time * 0.1) * Math.PI;
                    const nextRadius = (10 + nextRing.z * 0.5) * nextPerspective * pulse;
                    const nextX = cx + nextWobbleX * nextPerspective;
                    const nextY = cy + nextWobbleY * nextPerspective;
                    
                    ctx.save();
                    ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.2})`;
                    ctx.lineWidth = Math.max(0.2, 0.8 * perspective);
                    
                    const latticeSides = 6;
                    for (let i = 0; i < latticeSides; i++) {
                        const angle1 = tunnelTwist + (i / latticeSides) * Math.PI * 2;
                        const p1x = finalX + Math.cos(angle1) * radius;
                        const p1y = finalY + Math.sin(angle1) * radius;
                        
                        const angle2 = nextTwist + (i / latticeSides) * Math.PI * 2;
                        const p2x = nextX + Math.cos(angle2) * nextRadius;
                        const p2y = nextY + Math.sin(angle2) * nextRadius;
                        
                        ctx.beginPath();
                        ctx.moveTo(p1x, p1y);
                        ctx.lineTo(p2x, p2y);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
        }

        class Particle {
            constructor() { this.respawn(); }
            
            respawn() {
                this.z = Math.random() * 50;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * W * 1.5;
                this.x = cx + Math.cos(angle) * radius;
                this.y = cy + Math.sin(angle) * radius;
                this.vz = (Math.random() * 15 + 10); // Faster speed
                this.isStreak = Math.random() > 0.9;
                this.color = palette[Math.floor(Math.random() * palette.length)];
            }

            update(dt) {
                this.z -= dt * this.vz;
                if (this.z < 0.1) {
                    this.respawn();
                }
            }

            draw() {
                const perspective = 300 / this.z;
                const screenX = (this.x - cx) * perspective + cx;
                const screenY = (this.y - cy) * perspective + cy;

                const alpha = smoothstep(50, 40, this.z);
                const size = (this.isStreak ? 3 : 1.5) * perspective;
                
                if (screenX < 0 || screenX > W || screenY < 0 || screenY > H) {
                    this.respawn();
                    return;
                }
                
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;

                if (this.isStreak) {
                    const prevZ = this.z + this.vz * 0.1;
                    const prevPersp = 300 / prevZ;
                    const prevX = (this.x - cx) * prevPersp + cx;
                    const prevY = (this.y - cy) * prevPersp + cy;
                    ctx.lineWidth = size;
                    ctx.strokeStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(screenX, screenY);
                    ctx.stroke();
                } else {
                    ctx.fillRect(screenX - size / 2, screenY - size / 2, size, size);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        const rings = Array.from({ length: ringCount }, (_, i) => new TunnelRing(i * (50 / ringCount)));
        const particles = Array.from({ length: particleCount }, () => new Particle());

        function render() {
            const dt = 1 / 60;
            time += dt;
            mouse.update();

            ctx.fillStyle = 'rgba(1, 2, 6, 0.25)'; // Dark background with fade trail
            ctx.fillRect(0, 0, W, H);

            // --- Breathing Glow ---
            const glowPulse = Math.sin(time * 0.8) * 0.5 + 0.5;
            const glowRadius = W * (0.3 + glowPulse * 0.2);
            const glowGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowRadius);
            const breathColor1 = lerpColor(palette[0], palette[1], fract(time * 0.1));
            const breathColor2 = lerpColor(palette[2], palette[3], fract(time * 0.1 + 0.5));
            const rgb1 = hexToRgb(breathColor1);
            const rgb2 = hexToRgb(breathColor2);

            glowGradient.addColorStop(0, `rgba(${rgb1.r}, ${rgb1.g}, ${rgb1.b}, 0.15)`);
            glowGradient.addColorStop(0.5, `rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, 0.1)`);
            glowGradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = glowGradient;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();

            const speed = 10 + mouse.y * 20;

            rings.sort((a, b) => b.z - a.z);
            rings.forEach((ring, i) => {
                ring.update(dt, speed);
                const nextRing = rings.find(r => r.z > ring.z);
                ring.draw(nextRing);
            });
            
            particles.forEach(p => {
                p.update(dt);
                p.draw();
            });

            requestAnimationFrame(render);
        }

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(render);
    </script>
</body>
</html>
