<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JaZeR Vortex Spiral - Infinite Loop</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import {
        import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';

        // --- JaZeR UI schema (injected) ---
        const __jazerEffectFile = location.pathname.split('/').pop() || '';
        const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
        const { ui, expose, ready } = attachEffectUI({
          title: document.title,
          schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
        });
        window.JAZER_UI = ui;
        window.JAZER_EXPOSE = expose;
        window.JAZER_UI_READY = ready;
        // ------------------------------------

            noise2D, mouse, Easing,
            ColorPalettes, cycleColor, hexToRgb,
            map, clamp, smoothstep
        } from '../lib/engine/jazer-background-engine.js';
        import '../lib/engine/jazer-navigation.js';

        // =====================================================
        // CONFIGURATION
        // =====================================================
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        let W, H, cx, cy;
        let time = 0;

        // Neon color palette
        const neonPalette = ['#00ffff', '#ff00ff', '#9d00ff', '#00ccff', '#ff1aff'];

        // Spiral parameters
        const textCount = 180;          // More "JaZeR" instances in spiral
        const spiralTightness = 0.12;   // Slightly looser spiral
        const rotationSpeed = 0.6;      // Faster spiral rotation
        const zoomSpeed = 0.4;          // Faster inward zoom
        const pulseBPM = 128;           // Faster glow pulse

        // Text elements array
        const texts = [];

        // =====================================================
        // RESIZE HANDLER
        // =====================================================
        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            cx = W / 2;
            cy = H / 2;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // =====================================================
        // SPIRAL TEXT CLASS
        // =====================================================
        /**
         * SpiralText represents a "JaZeR" text element positioned on a logarithmic spiral.
         * The spiral continuously rotates and zooms inward for an infinite fall effect.
         */
        class SpiralText {
            constructor(index) {
                this.index = index;
                this.angle = (index / textCount) * Math.PI * 4; // Initial angle on spiral
                this.baseRadius = 50 + index * 8;               // Initial distance from center
                this.colorOffset = index / textCount;           // For color cycling
                this.pulsePhase = Math.random() * Math.PI * 2;  // Random pulse timing
            }

            /**
             * Calculate spiral position using logarithmic spiral formula
             * r = a * e^(b * Î¸)
             * We use a simplified version for performance
             */
            getPosition() {
                // Calculate current angle with rotation
                const currentAngle = this.angle + time * rotationSpeed;

                // Logarithmic spiral radius calculation
                // The radius decreases over time to create the inward zoom effect
                const zoomFactor = (time * zoomSpeed) % 10; // Loop every 10 seconds
                const spiralRadius = this.baseRadius * Math.exp(-spiralTightness * currentAngle) - zoomFactor * 30;

                // Loop the spiral when it gets too small
                let radius = spiralRadius;
                if (radius < 10) {
                    radius += 800; // Reset to outer edge
                }

                // Calculate X and Y from polar coordinates
                const x = cx + Math.cos(currentAngle) * radius;
                const y = cy + Math.sin(currentAngle) * radius;

                return { x, y, radius, angle: currentAngle };
            }

            /**
             * Draw the text with glow pulses
             */
            draw() {
                const pos = this.getPosition();

                // Calculate opacity based on distance from center (fade out at edges)
                const distFromCenter = pos.radius;
                const fadeIn = smoothstep(10, 100, distFromCenter);
                const fadeOut = smoothstep(800, 600, distFromCenter);
                let alpha = fadeIn * fadeOut;

                // Add periodic glow pulse synchronized to BPM
                const pulseFrequency = (pulseBPM / 60) * Math.PI * 2; // Convert BPM to rad/s
                const pulse = Math.sin(time * pulseFrequency + this.pulsePhase);
                const glowIntensity = map(pulse, -1, 1, 0.6, 1.4);
                alpha *= glowIntensity;

                if (alpha < 0.05) return; // Skip if nearly invisible

                // Get color from palette with cycling
                const colorIndex = Math.floor((time * 0.3 + this.colorOffset * 5) % neonPalette.length);
                const color = neonPalette[colorIndex];
                const rgb = hexToRgb(color);

                // Calculate size based on distance (perspective)
                const scale = map(distFromCenter, 10, 800, 2.0, 0.5);
                const fontSize = Math.max(12, 20 * scale);

                // Add subtle wobble using noise
                const wobbleX = noise2D(this.index * 0.1, time * 0.5) * 5;
                const wobbleY = noise2D(this.index * 0.1 + 100, time * 0.5) * 5;

                // Configure text rendering
                ctx.font = `bold ${fontSize}px "Arial", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw text with glow
                ctx.save();
                ctx.translate(pos.x + wobbleX, pos.y + wobbleY);

                // Rotate text along the spiral tangent
                ctx.rotate(pos.angle + Math.PI / 2);

                // Glow effect with pulse
                const blurAmount = 15 * scale * glowIntensity;
                ctx.shadowColor = color;
                ctx.shadowBlur = blurAmount;
                ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;

                // Draw text multiple times for stronger glow during pulse
                const drawCount = pulse > 0.5 ? 3 : 2;
                for (let g = 0; g < drawCount; g++) {
                    ctx.fillText('JaZeR', 0, 0);
                }

                ctx.restore();
            }
        }

        // =====================================================
        // INITIALIZATION
        // =====================================================
        /**
         * Initialize all spiral text elements
         */
        function init() {
            texts.length = 0;
            for (let i = 0; i < textCount; i++) {
                texts.push(new SpiralText(i));
            }
        }

        // =====================================================
        // ANIMATION LOOP
        // =====================================================
        /**
         * Main render loop - draws the spiraling vortex of text
         * @param {number} now - Current timestamp in milliseconds
         */
        function render(now) {
            const timeScale = window.JAZER_UI?.params?.timeScale ?? 1;
            const dt = (1 / 60) * timeScale; // Assume 60fps
            time += dt;

            // Update mouse tracking
            mouse.update();

            // Clear canvas with fade trail for hypnotic effect
            ctx.fillStyle = 'rgba(0, 0, 20, 0.12)';
            ctx.fillRect(0, 0, W, H);

            // Draw central vortex glow
            const vortexColor = cycleColor(neonPalette, time * 0.4);
            const vortexRgb = hexToRgb(vortexColor);
            const pulseSize = 20 + Math.sin(time * (pulseBPM / 60) * Math.PI * 2) * 8;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowColor = vortexColor;
            ctx.shadowBlur = 40;
            ctx.fillStyle = `rgba(${vortexRgb.r}, ${vortexRgb.g}, ${vortexRgb.b}, 0.7)`;
            ctx.beginPath();
            ctx.arc(cx, cy, pulseSize, 0, Math.PI * 2);
            ctx.fill();

            // Draw depth particles around vortex center
            for (let i = 0; i < 40; i++) {
                const pAngle = (i / 40) * Math.PI * 2 + time * 1.5;
                const pDist = 25 + Math.sin(time * 3 + i * 0.5) * 15;
                const pSize = 1 + Math.sin(time * 4 + i) * 0.5;
                const pAlpha = 0.3 + Math.sin(time * 2 + i) * 0.2;

                ctx.fillStyle = `rgba(${vortexRgb.r}, ${vortexRgb.g}, ${vortexRgb.b}, ${pAlpha})`;
                ctx.beginPath();
                ctx.arc(
                    cx + Math.cos(pAngle) * pDist,
                    cy + Math.sin(pAngle) * pDist,
                    pSize, 0, Math.PI * 2
                );
                ctx.fill();
            }
            ctx.restore();

            // Draw all spiral texts (from outside to inside for proper layering)
            for (let i = texts.length - 1; i >= 0; i--) {
                texts[i].draw();
            }

            // Vignette effect for depth
            const vig = ctx.createRadialGradient(cx, cy, Math.min(W, H) * 0.2, cx, cy, Math.max(W, H) * 0.65);
            vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vig.addColorStop(1, 'rgba(0, 0, 20, 0.5)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);

            requestAnimationFrame(render);
        }

        // =====================================================
        // START THE EFFECT
        // =====================================================
        window.addEventListener('resize', resize);
        resize();
        init();
        requestAnimationFrame(render);
    </script>
</body>

</html>