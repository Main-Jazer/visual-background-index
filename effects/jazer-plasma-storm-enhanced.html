<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plasma Storm - JaZeR [Enhanced]</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* Debug overlay */
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #ff2aff;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #debug.visible {
            opacity: 1;
        }

        /* Controls hint */
        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Consolas', monospace;
            font-size: 11px;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <div id="debug"></div>
    <div id="controls">
        [B] Toggle Post-FX | [P] Cycle Presets | [D] Debug Info | [1-4] Quality
    </div>

    <script type="module">
        // ============================================================================
        // PLASMA STORM - ENHANCED WITH CANVAS 2D POST-PROCESSING
        // ============================================================================
        // This effect demonstrates the JaZeR Canvas 2D post-processing pipeline
        // with bloom, chromatic aberration, vignette, tonemapping, and grain.
        // ============================================================================

        import { noise2D, noise3D, mouse, hexToRgb, smoothstep } from '../jazer-background-engine.js';

        // NEW: Import JaZeR Canvas post-processing
        import { createCanvasPipeline } from '../jazer-canvas-fx.js';
        import { FX_PRESETS } from '../jazer-post-fx.js';

        const canvas = document.getElementById('c');
        const debugEl = document.getElementById('debug');
        const dpr = Math.min(window.devicePixelRatio || 1, 2);

        let W, H;
        let time = 0;

        // ============================================================================
        // CREATE POST-PROCESSING PIPELINE
        // ============================================================================
        // This wraps all Canvas 2D rendering with professional post-processing

        const postFX = createCanvasPipeline(canvas, {
            preset: 'neon',     // 'subtle', 'neon', 'cinematic', 'extreme'
            quality: 'high',    // 'low', 'medium', 'high', 'ultra'
            enabled: true
        });

        // ============================================================================
        // PLASMA COLORS
        // ============================================================================

        const plasmaColors = ['#ff0055', '#ff2aff', '#00f5ff', '#39ff14', '#ffd700', '#ff6b00'];

        // ============================================================================
        // RESIZE HANDLER
        // ============================================================================

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
        }

        // ============================================================================
        // LIGHTNING DRAWING
        // ============================================================================

        function drawLightning(ctx, x1, y1, x2, y2, segments, displacement, color, alpha) {
            const points = [{ x: x1, y: y1 }];

            function subdivide(start, end, disp) {
                if (disp < 2) return;
                const mid = {
                    x: (start.x + end.x) / 2 + (Math.random() - 0.5) * disp,
                    y: (start.y + end.y) / 2 + (Math.random() - 0.5) * disp
                };
                const startIdx = points.indexOf(start);
                const endIdx = points.indexOf(end);
                points.splice(endIdx, 0, mid);
                subdivide(start, mid, disp * 0.6);
                subdivide(mid, end, disp * 0.6);
            }

            points.push({ x: x2, y: y2 });
            subdivide(points[0], points[1], displacement);

            const rgb = hexToRgb(color);

            // Outer glow
            ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.3})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke();

            // Main line
            ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke();

            // Core highlight
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // ============================================================================
        // PLASMA ORB CLASS
        // ============================================================================

        class PlasmaOrb {
            constructor(w, h) {
                this.w = w;
                this.h = h;
                this.reset();
            }

            reset() {
                this.x = Math.random() * this.w;
                this.y = Math.random() * this.h;
                this.size = 20 + Math.random() * 60;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.colorIndex = Math.floor(Math.random() * plasmaColors.length);
                this.pulseSpeed = 1 + Math.random() * 2;
                this.noiseOffset = Math.random() * 1000;
            }

            update(dt, mouseX, mouseY, time) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 300 && dist > 10) {
                    this.vx += (dx / dist) * 0.5;
                    this.vy += (dy / dist) * 0.5;
                }

                this.vx += noise2D(this.x * 0.003, time * 0.5 + this.noiseOffset) * 0.3;
                this.vy += noise2D(this.y * 0.003, time * 0.5 + this.noiseOffset + 100) * 0.3;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < -100) this.x = this.w + 100;
                if (this.x > this.w + 100) this.x = -100;
                if (this.y < -100) this.y = this.h + 100;
                if (this.y > this.h + 100) this.y = -100;
            }

            draw(ctx, time) {
                if (!isFinite(this.x) || !isFinite(this.y)) {
                    this.reset();
                    return;
                }

                const pulse = Math.sin(time * this.pulseSpeed) * 0.3 + 1;
                const size = this.size * pulse;
                const color = plasmaColors[this.colorIndex];
                const rgb = hexToRgb(color);

                // Multiple glow layers
                for (let i = 4; i >= 0; i--) {
                    const layerSize = size * (1 + i * 0.5);
                    const alpha = 0.15 / (i + 1);
                    const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, layerSize);
                    grad.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.5})`);
                    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, layerSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Energy tendrils
                const tendrilCount = 6;
                for (let i = 0; i < tendrilCount; i++) {
                    const angle = (i / tendrilCount) * Math.PI * 2 + time * 0.5;
                    const len = size * (0.8 + noise2D(i + time, this.noiseOffset) * 0.5);
                    const endX = this.x + Math.cos(angle) * len;
                    const endY = this.y + Math.sin(angle) * len;
                    ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.4)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.quadraticCurveTo(
                        this.x + Math.cos(angle + 0.3) * len * 0.5,
                        this.y + Math.sin(angle + 0.3) * len * 0.5,
                        endX, endY
                    );
                    ctx.stroke();
                }
            }
        }

        // ============================================================================
        // SCENE STATE
        // ============================================================================

        let orbs = [];

        // ============================================================================
        // SCENE DRAWING FUNCTION
        // ============================================================================
        // This function is passed to the post-processing pipeline
        // It draws the raw scene which then gets enhanced with bloom, etc.

        function drawScene(ctx, w, h) {
            // Scale for device pixel ratio
            const scaleX = w / W;
            const scaleY = h / H;
            ctx.save();
            ctx.scale(scaleX, scaleY);

            // Background gradient
            const bgGrad = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H));
            bgGrad.addColorStop(0, '#100010');
            bgGrad.addColorStop(1, '#000005');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            // Fade layer
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, W, H);

            // Additive blending for plasma effects
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            const dt = 1 / 60;
            const mx = mouse.x * W;
            const my = mouse.y * H;

            // Update and draw orbs
            orbs.forEach(orb => {
                orb.update(dt, mx, my, time);
                orb.draw(ctx, time);
            });

            // Lightning between close orbs
            for (let i = 0; i < orbs.length; i++) {
                for (let j = i + 1; j < orbs.length; j++) {
                    const dx = orbs[j].x - orbs[i].x;
                    const dy = orbs[j].y - orbs[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 400 && Math.random() < 0.1) {
                        const alpha = smoothstep(400, 100, dist);
                        const color = plasmaColors[Math.floor(time * 2) % plasmaColors.length];
                        drawLightning(ctx, orbs[i].x, orbs[i].y, orbs[j].x, orbs[j].y, 5, 50, color, alpha * 0.6);
                    }
                }
            }

            // Lightning to mouse
            if (mx > 0 && Math.random() < 0.15) {
                const nearestOrb = orbs.reduce((nearest, orb) => {
                    const d = Math.hypot(orb.x - mx, orb.y - my);
                    return d < nearest.d ? { orb, d } : nearest;
                }, { orb: orbs[0], d: Infinity });
                if (nearestOrb.d < 400) {
                    drawLightning(ctx, nearestOrb.orb.x, nearestOrb.orb.y, mx, my, 5, 60, '#00f5ff', 0.7);
                }
            }

            ctx.restore();

            // Scanlines
            ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
            for (let y = 0; y < H; y += 3) ctx.fillRect(0, y, W, 1);

            // JaZeR watermark
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.font = 'bold 120px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const textGrad = ctx.createLinearGradient(W / 2 - 200, 0, W / 2 + 200, 0);
            const t = time * 0.5;
            textGrad.addColorStop(0, plasmaColors[Math.floor(t) % plasmaColors.length]);
            textGrad.addColorStop(0.5, plasmaColors[Math.floor(t + 1) % plasmaColors.length]);
            textGrad.addColorStop(1, plasmaColors[Math.floor(t + 2) % plasmaColors.length]);

            ctx.fillStyle = textGrad;
            ctx.globalAlpha = 0.04 + Math.sin(time * 2) * 0.02;
            ctx.fillText('JaZeR', W / 2, H / 2);
            ctx.restore();

            ctx.restore();
        }

        // ============================================================================
        // KEYBOARD CONTROLS
        // ============================================================================

        const presetNames = ['subtle', 'neon', 'cinematic', 'extreme'];
        let currentPresetIndex = 1; // Start with 'neon'
        let showDebug = false;

        document.addEventListener('keydown', (e) => {
            switch (e.key.toLowerCase()) {
                case 'b':
                    const enabled = postFX.toggle();
                    console.log(`Post-FX: ${enabled ? 'ON' : 'OFF'}`);
                    break;
                case 'p':
                    currentPresetIndex = (currentPresetIndex + 1) % presetNames.length;
                    const preset = presetNames[currentPresetIndex];
                    postFX.setPreset(preset);
                    console.log(`Preset: ${preset}`);
                    break;
                case 'd':
                    showDebug = !showDebug;
                    debugEl.classList.toggle('visible', showDebug);
                    break;
                case '1':
                    postFX.setQuality('low');
                    console.log('Quality: low');
                    break;
                case '2':
                    postFX.setQuality('medium');
                    console.log('Quality: medium');
                    break;
                case '3':
                    postFX.setQuality('high');
                    console.log('Quality: high');
                    break;
                case '4':
                    postFX.setQuality('ultra');
                    console.log('Quality: ultra');
                    break;
            }
        });

        // ============================================================================
        // ANIMATION LOOP
        // ============================================================================

        let lastTime = performance.now();

        function render() {
            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;

            time += deltaTime;
            mouse.update();

            // ================================================================
            // RENDER WITH POST-PROCESSING
            // ================================================================
            // OLD: Draw directly to canvas context
            // NEW: Use pipeline which applies bloom, chromatic, vignette, etc.
            postFX.render(drawScene, deltaTime);

            // Update debug overlay
            if (showDebug) {
                const info = postFX.getDebugInfo();
                debugEl.innerHTML = `
                    Preset: ${info.preset}<br>
                    Quality: ${info.quality}<br>
                    Refresh: ${info.refreshRate}Hz<br>
                    FX: ${info.enabled ? 'ON' : 'OFF'}<br>
                    Time: ${info.time}s
                `;
            }

            requestAnimationFrame(render);
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        window.addEventListener('resize', resize);
        resize();

        // Create plasma orbs
        orbs = Array.from({ length: 8 }, () => new PlasmaOrb(W, H));

        // Start animation
        requestAnimationFrame(render);
    </script>
</body>

</html>