<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plasma Storm - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <script type="module">
        /**
         * ============================================================================
         * PLASMA STORM - HIGH-END VISUAL ART
         * ============================================================================
         * CHANGELOG v2.0 - Artistic Upgrade
         * - Constrained palette: Electric cyan primary + violet secondary + white discharge
         * - Removed 6-color random cycling
         * - Episodic storm events: calm → build → discharge → calm (15-second cycle)
         * - Reduced lightning frequency - fires only during storm peaks
         * - Removed large JaZeR watermark text
         * - Established visual hierarchy: Primary orbs (focal), lightning (accent)
         * - Camera: Stable, let the storm be the motion
         * - Finish: Darker ambient between storms
         * 
         * THESIS: "Primal power with direction, chaos shaped into flow"
         * ============================================================================
         */

        import { noise2D, noise3D, mouse, hexToRgb, smoothstep } from '../lib/engine/jazer-background-engine.js';
        import '../lib/engine/jazer-navigation.js';

        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dpr = Math.min(window.devicePixelRatio || 1, 2);

        let W, H;
        let time = 0;

        // === COLOR PALETTE (Restrained) ===
        const COLORS = {
            primary: '#00ccff',     // Electric cyan
            secondary: '#9944ff',   // Royal violet
            tertiary: '#6622cc',    // Deep purple
            discharge: '#ffffff',   // Pure white for lightning peaks
            darkAmbient: '#050508'  // Near black
        };

        // === STORM CYCLE PARAMETERS ===
        const STORM_PERIOD = 15; // 15-second full cycle

        // Storm intensity function: calm → build → peak discharge → decay → calm
        function getStormIntensity(t) {
            const normalized = (t % STORM_PERIOD) / STORM_PERIOD;

            // Calm phase: 0.0 - 0.4
            if (normalized < 0.4) {
                return normalized / 0.4 * 0.3; // Slowly build to 0.3
            }
            // Build phase: 0.4 - 0.6
            else if (normalized < 0.6) {
                const buildT = (normalized - 0.4) / 0.2;
                return 0.3 + buildT * 0.7; // Build from 0.3 to 1.0
            }
            // Peak discharge: 0.6 - 0.7
            else if (normalized < 0.7) {
                return 1.0; // Full intensity
            }
            // Decay: 0.7 - 1.0
            else {
                const decayT = (normalized - 0.7) / 0.3;
                return 1.0 - decayT * 0.7; // Decay from 1.0 to 0.3
            }
        }

        // === RESIZE HANDLER ===
        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // === LIGHTNING DRAWING (Refined) ===
        function drawLightning(x1, y1, x2, y2, displacement, color, alpha, width) {
            if (alpha < 0.05) return;

            const points = [{ x: x1, y: y1 }];

            function subdivide(start, end, disp) {
                if (disp < 3) return;
                const mid = {
                    x: (start.x + end.x) / 2 + (Math.random() - 0.5) * disp,
                    y: (start.y + end.y) / 2 + (Math.random() - 0.5) * disp
                };
                const startIdx = points.indexOf(start);
                const endIdx = points.indexOf(end);
                points.splice(endIdx, 0, mid);
                subdivide(start, mid, disp * 0.6);
                subdivide(mid, end, disp * 0.6);
            }

            points.push({ x: x2, y: y2 });
            subdivide(points[0], points[1], displacement);

            const rgb = hexToRgb(color);

            // Outer glow
            ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.25})`;
            ctx.lineWidth = width * 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke();

            // Main line
            ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.7})`;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke();

            // White core
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
            ctx.lineWidth = width * 0.3;
            ctx.stroke();
        }

        // === PLASMA ORB CLASS (Refined) ===
        class PlasmaOrb {
            constructor(w, h, colorIndex) {
                this.w = w;
                this.h = h;
                this.colorIndex = colorIndex;
                this.reset();
            }

            reset() {
                this.x = Math.random() * this.w;
                this.y = Math.random() * this.h;
                this.size = 40 + Math.random() * 80;
                this.vx = (Math.random() - 0.5) * 1.5;
                this.vy = (Math.random() - 0.5) * 1.5;
                this.pulseSpeed = 0.8 + Math.random() * 0.8;
                this.noiseOffset = Math.random() * 1000;
            }

            update(dt, mouseX, mouseY, time, stormIntensity) {
                // Gentle attraction to mouse
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 350 && dist > 15) {
                    const attraction = 0.15 + stormIntensity * 0.2;
                    this.vx += (dx / dist) * attraction;
                    this.vy += (dy / dist) * attraction;
                }

                // Noise-based movement - more during storm
                const noiseStrength = 0.15 + stormIntensity * 0.25;
                this.vx += noise2D(this.x * 0.002, time * 0.3 + this.noiseOffset) * noiseStrength;
                this.vy += noise2D(this.y * 0.002, time * 0.3 + this.noiseOffset + 100) * noiseStrength;

                // Damping
                const damping = 0.97 - stormIntensity * 0.02;
                this.vx *= damping;
                this.vy *= damping;

                this.x += this.vx;
                this.y += this.vy;

                // Boundary wrapping
                if (this.x < -120) this.x = this.w + 120;
                if (this.x > this.w + 120) this.x = -120;
                if (this.y < -120) this.y = this.h + 120;
                if (this.y > this.h + 120) this.y = -120;
            }

            draw(time, stormIntensity) {
                if (!isFinite(this.x) || !isFinite(this.y)) {
                    this.reset();
                    return;
                }

                // Determine color based on index (alternating primary/secondary)
                const color = this.colorIndex % 2 === 0 ? COLORS.primary : COLORS.secondary;
                const rgb = hexToRgb(color);

                // Pulse intensity follows storm cycle
                const basePulse = Math.sin(time * this.pulseSpeed) * 0.15 + 0.85;
                const pulse = basePulse * (0.5 + stormIntensity * 0.5);
                const size = this.size * pulse;

                // Multiple glow layers
                for (let i = 3; i >= 0; i--) {
                    const layerSize = size * (1 + i * 0.6);
                    const alpha = (0.08 + stormIntensity * 0.08) / (i + 1);
                    const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, layerSize);
                    grad.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.4})`);
                    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, layerSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Energy tendrils - more visible during storm
                if (stormIntensity > 0.3) {
                    const tendrilCount = 5;
                    for (let i = 0; i < tendrilCount; i++) {
                        const angle = (i / tendrilCount) * Math.PI * 2 + time * 0.3;
                        const len = size * (0.6 + noise2D(i + time * 0.5, this.noiseOffset) * 0.4);
                        const endX = this.x + Math.cos(angle) * len;
                        const endY = this.y + Math.sin(angle) * len;

                        ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${stormIntensity * 0.3})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.quadraticCurveTo(
                            this.x + Math.cos(angle + 0.4) * len * 0.5,
                            this.y + Math.sin(angle + 0.4) * len * 0.5,
                            endX, endY
                        );
                        ctx.stroke();
                    }
                }
            }
        }

        // === SCENE STATE ===
        const orbs = [];
        const ORB_COUNT = 6; // Reduced from 8

        // === RENDER FUNCTION ===
        function render() {
            const stormIntensity = getStormIntensity(time);

            // Background - darker during calm phases
            const bgAlpha = 0.12 + (1 - stormIntensity) * 0.08;
            ctx.fillStyle = `rgba(5, 5, 8, ${bgAlpha})`;
            ctx.fillRect(0, 0, W, H);

            // Additive blending for plasma effects
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            const dt = 1 / 60;
            const mx = mouse.x * W;
            const my = mouse.y * H;

            // Update and draw orbs
            orbs.forEach(orb => {
                orb.update(dt, mx, my, time, stormIntensity);
                orb.draw(time, stormIntensity);
            });

            // Lightning between close orbs - ONLY during storm peaks (intensity > 0.7)
            if (stormIntensity > 0.7) {
                for (let i = 0; i < orbs.length; i++) {
                    for (let j = i + 1; j < orbs.length; j++) {
                        const dx = orbs[j].x - orbs[i].x;
                        const dy = orbs[j].y - orbs[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // Higher threshold for lightning, random chance
                        if (dist < 350 && Math.random() < 0.15 * stormIntensity) {
                            const alpha = smoothstep(350, 100, dist) * (stormIntensity - 0.7) / 0.3;
                            drawLightning(orbs[i].x, orbs[i].y, orbs[j].x, orbs[j].y,
                                40, COLORS.primary, alpha * 0.7, 2);
                        }
                    }
                }
            }

            // Lightning to mouse - ONLY during peak storm
            if (mx > 0 && stormIntensity > 0.85 && Math.random() < 0.2) {
                const nearestOrb = orbs.reduce((nearest, orb) => {
                    const d = Math.hypot(orb.x - mx, orb.y - my);
                    return d < nearest.d ? { orb, d } : nearest;
                }, { orb: orbs[0], d: Infinity });

                if (nearestOrb.d < 350) {
                    const alpha = (stormIntensity - 0.85) / 0.15;
                    drawLightning(nearestOrb.orb.x, nearestOrb.orb.y, mx, my,
                        50, COLORS.discharge, alpha * 0.8, 2.5);
                }
            }

            ctx.restore();

            // Subtle scanlines
            ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
            for (let y = 0; y < H; y += 4) ctx.fillRect(0, y, W, 1);

            // Vignette - stronger during calm
            const vignetteStrength = 0.4 + (1 - stormIntensity) * 0.2;
            const vignette = ctx.createRadialGradient(W / 2, H / 2, Math.min(W, H) * 0.3,
                W / 2, H / 2, Math.max(W, H) * 0.7);
            vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vignette.addColorStop(1, `rgba(0, 0, 0, ${vignetteStrength})`);
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, W, H);
        }

        // === ANIMATION LOOP ===
        let lastTime = performance.now();

        function animate() {
            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;

            time += deltaTime;
            mouse.update();

            render();

            requestAnimationFrame(animate);
        }

        // === INITIALIZATION ===
        window.addEventListener('resize', resize);
        resize();

        // Create plasma orbs with alternating colors
        for (let i = 0; i < ORB_COUNT; i++) {
            orbs.push(new PlasmaOrb(W, H, i));
        }

        // Start animation
        requestAnimationFrame(animate);
    </script>
</body>

</html>