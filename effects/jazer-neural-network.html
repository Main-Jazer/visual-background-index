<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neural Network Universe - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import { mouse } from '../lib/engine/jazer-background-engine.js';
        import '../lib/engine/jazer-navigation.js';
        import * as THREE from '../lib/Three.js';
        import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';
        // --- JaZeR UI schema (injected) ---
        const __jazerEffectFile = location.pathname.split('/').pop() || '';
        const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
        const { ui, expose, ready } = attachEffectUI({
          title: document.title,
          schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
        });
        window.JAZER_UI = ui;
        window.JAZER_EXPOSE = expose;
        window.JAZER_UI_READY = ready;
        // ------------------------------------


        window.THREE = THREE;
        const canvas = document.getElementById('c');
        let width = window.innerWidth;
        let height = window.innerHeight;

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.008);
        scene.background = new THREE.Color(0x000510);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.z = 35;
        camera.position.y = 5;
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Auto-rotation speed
        const autoRotateSpeed = 0.3;

        // Neon color palette
        const neonColors = [0xff0055, 0x00f5ff, 0xff2aff, 0xffd700, 0x39ff14, 0xb37cff];

        // Create network nodes in 3D space
        const nodeCount = 180;
        const nodes = [];
        const nodeGroup = new THREE.Group();
        scene.add(nodeGroup);

        for (let i = 0; i < nodeCount; i++) {
            const x = (Math.random() - 0.5) * 50;
            const y = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;

            const colorHex = neonColors[Math.floor(Math.random() * neonColors.length)];

            // Core node sphere
            const nodeGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const nodeMat = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.95,
                blending: THREE.AdditiveBlending
            });

            const node = new THREE.Mesh(nodeGeo, nodeMat);
            node.position.set(x, y, z);

            // Glow sphere around node
            const glowGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            node.add(glow);

            // Store userData for animation
            node.userData = {
                baseColor: new THREE.Color(colorHex),
                glow: glow,
                pulse: Math.random() * Math.PI * 2,
                pulseSpeed: 0.5 + Math.random() * 2,
                originalPosition: new THREE.Vector3(x, y, z)
            };

            nodeGroup.add(node);
            nodes.push(node);
        }

        // Create connections between nearby nodes
        const connections = [];
        const connectionGroup = new THREE.Group();
        scene.add(connectionGroup);
        const maxConnectionDistance = 10;

        for (let i = 0; i < nodes.length; i++) {
            let connectionCount = 0;
            const maxConnections = 4;

            for (let j = i + 1; j < nodes.length && connectionCount < maxConnections; j++) {
                const dist = nodes[i].position.distanceTo(nodes[j].position);

                if (dist < maxConnectionDistance) {
                    const points = [nodes[i].position.clone(), nodes[j].position.clone()];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);

                    // Gradient color based on connected nodes
                    const colorA = nodes[i].userData.baseColor;
                    const colorB = nodes[j].userData.baseColor;
                    const avgColor = new THREE.Color().lerpColors(colorA, colorB, 0.5);

                    const material = new THREE.LineBasicMaterial({
                        color: avgColor,
                        transparent: true,
                        opacity: 0.25,
                        blending: THREE.AdditiveBlending
                    });

                    const line = new THREE.Line(geometry, material);
                    line.userData = {
                        nodeA: nodes[i],
                        nodeB: nodes[j],
                        baseOpacity: 0.25,
                        baseColor: avgColor
                    };

                    connectionGroup.add(line);
                    connections.push(line);
                    connectionCount++;
                }
            }
        }

        // Energy pulses traveling along connections
        const pulses = [];
        const pulseCount = 60;

        for (let i = 0; i < pulseCount && connections.length > 0; i++) {
            const connection = connections[Math.floor(Math.random() * connections.length)];

            const pulseGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const pulseMat = new THREE.MeshBasicMaterial({
                color: neonColors[Math.floor(Math.random() * neonColors.length)],
                transparent: true,
                opacity: 0.95,
                blending: THREE.AdditiveBlending
            });

            const pulse = new THREE.Mesh(pulseGeo, pulseMat);
            pulse.userData = {
                connection: connection,
                progress: Math.random(),
                speed: 0.003 + Math.random() * 0.008,
                direction: Math.random() > 0.5 ? 1 : -1
            };

            connectionGroup.add(pulse);
            pulses.push(pulse);
        }

        // Background particle field (stars)
        const bgParticleCount = 2500;
        const bgParticleGeo = new THREE.BufferGeometry();
        const bgPositions = new Float32Array(bgParticleCount * 3);
        const bgColors = new Float32Array(bgParticleCount * 3);
        const bgSizes = new Float32Array(bgParticleCount);

        for (let i = 0; i < bgParticleCount; i++) {
            // Spherical distribution
            const radius = 80 + Math.random() * 120;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            bgPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            bgPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            bgPositions[i * 3 + 2] = radius * Math.cos(phi);

            const color = new THREE.Color(neonColors[Math.floor(Math.random() * neonColors.length)]);
            bgColors[i * 3] = color.r;
            bgColors[i * 3 + 1] = color.g;
            bgColors[i * 3 + 2] = color.b;

            bgSizes[i] = 0.5 + Math.random() * 1.5;
        }

        bgParticleGeo.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
        bgParticleGeo.setAttribute('color', new THREE.BufferAttribute(bgColors, 3));

        const bgParticleMat = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const bgParticles = new THREE.Points(bgParticleGeo, bgParticleMat);
        scene.add(bgParticles);

        // Animation state
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += (0.016) * (window.JAZER_UI?.params?.timeScale ?? 1);
            mouse.update();

            // Auto-rotate camera
            const radius = 35;
            camera.position.x = Math.cos(time * autoRotateSpeed * 0.01) * radius;
            camera.position.z = Math.sin(time * autoRotateSpeed * 0.01) * radius;
            camera.lookAt(0, 0, 0);

            // Pulse and animate nodes
            nodes.forEach(node => {
                const pulseValue = Math.sin(time * node.userData.pulseSpeed + node.userData.pulse) * 0.5 + 0.5;

                // Scale pulse
                const scale = 1 + pulseValue * 0.25;
                node.scale.setScalar(scale);
                node.userData.glow.scale.setScalar(1 + pulseValue * 0.4);
                node.userData.glow.material.opacity = 0.1 + pulseValue * 0.15;

                // Subtle floating motion
                const orig = node.userData.originalPosition;
                node.position.y = orig.y + Math.sin(time * 0.5 + node.userData.pulse) * 0.3;
            });

            // Animate pulses along connections
            pulses.forEach(pulse => {
                pulse.userData.progress += pulse.userData.speed * pulse.userData.direction;

                // Bounce or switch connection at ends
                if (pulse.userData.progress >= 1 || pulse.userData.progress <= 0) {
                    if (Math.random() > 0.7) {
                        // Switch to random connection
                        pulse.userData.connection = connections[Math.floor(Math.random() * connections.length)];
                        pulse.userData.progress = pulse.userData.direction > 0 ? 0 : 1;
                    } else {
                        // Reverse direction
                        pulse.userData.direction *= -1;
                        pulse.userData.progress = Math.max(0, Math.min(1, pulse.userData.progress));
                    }
                }

                const conn = pulse.userData.connection;
                const nodeA = conn.userData.nodeA.position;
                const nodeB = conn.userData.nodeB.position;

                // Lerp position along connection
                pulse.position.lerpVectors(nodeA, nodeB, pulse.userData.progress);

                // Highlight connection when pulse passes
                const brightness = 1 - Math.abs(pulse.userData.progress - 0.5) * 2;
                conn.material.opacity = conn.userData.baseOpacity + brightness * 0.5;

                // Pulse scale
                const pulseScale = 0.6 + Math.sin(pulse.userData.progress * Math.PI) * 0.4;
                pulse.scale.setScalar(pulseScale);
            });

            // Slow gentle rotation of network
            nodeGroup.rotation.y += 0.0008;
            connectionGroup.rotation.y += 0.0008;

            // Background particles slow rotation
            bgParticles.rotation.y += 0.0002;
            bgParticles.rotation.x += 0.0001;

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // Start animation
        animate();
    </script>
</body>

</html>
