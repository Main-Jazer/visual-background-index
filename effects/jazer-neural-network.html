<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neural Network Universe - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import { mouse } from '../jazer-background-engine.js';

        import * as THREE from '../Three.js';
        window.THREE = THREE;
        const canvas = document.getElementById('c');

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const neonColors = [0xff0055, 0x00f5ff, 0xff2aff, 0xffd700, 0x39ff14, 0xb37cff];

        // Create network nodes in 3D space
        const nodeCount = 150;
        const nodes = [];
        const nodeGroup = new THREE.Group();

        for (let i = 0; i < nodeCount; i++) {
            const x = (Math.random() - 0.5) * 50;
            const y = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;

            const nodeGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const nodeMat = new THREE.MeshBasicMaterial({
                color: neonColors[Math.floor(Math.random() * neonColors.length)],
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });

            const node = new THREE.Mesh(nodeGeo, nodeMat);
            node.position.set(x, y, z);

            // Glow sphere around node
            const glowGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: nodeMat.color,
                transparent: true,
                opacity: 0.2,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            node.add(glow);

            node.userData = {
                baseColor: nodeMat.color.clone(),
                glow: glow,
                pulse: Math.random() * Math.PI * 2,
                pulseSpeed: 0.5 + Math.random() * 2
            };

            nodeGroup.add(node);
            nodes.push(node);
        }
        scene.add(nodeGroup);

        // Create connections between nearby nodes
        const connections = [];
        const maxConnectionDistance = 8;

        for (let i = 0; i < nodes.length; i++) {
            let connectionCount = 0;
            const maxConnections = 5;

            for (let j = i + 1; j < nodes.length && connectionCount < maxConnections; j++) {
                const dist = nodes[i].position.distanceTo(nodes[j].position);

                if (dist < maxConnectionDistance) {
                    const points = [nodes[i].position.clone(), nodes[j].position.clone()];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);

                    const material = new THREE.LineBasicMaterial({
                        color: 0x00f5ff,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    });

                    const line = new THREE.Line(geometry, material);
                    line.userData = {
                        nodeA: nodes[i],
                        nodeB: nodes[j],
                        baseOpacity: 0.3
                    };

                    nodeGroup.add(line);
                    connections.push(line);
                    connectionCount++;
                }
            }
        }

        // Energy pulses traveling along connections
        const pulses = [];
        const pulseCount = 80;

        for (let i = 0; i < pulseCount; i++) {
            const connection = connections[Math.floor(Math.random() * connections.length)];

            const pulseGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const pulseMat = new THREE.MeshBasicMaterial({
                color: neonColors[Math.floor(Math.random() * neonColors.length)],
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });

            const pulse = new THREE.Mesh(pulseGeo, pulseMat);
            pulse.userData = {
                connection: connection,
                progress: Math.random(),
                speed: 0.005 + Math.random() * 0.01,
                trailPositions: []
            };

            nodeGroup.add(pulse);
            pulses.push(pulse);
        }

        // Background particle field
        const bgParticleCount = 3000;
        const bgParticleGeo = new THREE.BufferGeometry();
        const bgPositions = new Float32Array(bgParticleCount * 3);
        const bgColors = new Float32Array(bgParticleCount * 3);

        for (let i = 0; i < bgParticleCount; i++) {
            bgPositions[i * 3] = (Math.random() - 0.5) * 200;
            bgPositions[i * 3 + 1] = (Math.random() - 0.5) * 200;
            bgPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;

            const color = new THREE.Color(neonColors[Math.floor(Math.random() * neonColors.length)]);
            bgColors[i * 3] = color.r;
            bgColors[i * 3 + 1] = color.g;
            bgColors[i * 3 + 2] = color.b;
        }

        bgParticleGeo.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
        bgParticleGeo.setAttribute('color', new THREE.BufferAttribute(bgColors, 3));

        const bgParticleMat = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const bgParticles = new THREE.Points(bgParticleGeo, bgParticleMat);
        scene.add(bgParticles);

        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            mouse.update();

            // Pulse nodes
            nodes.forEach(node => {
                const pulse = Math.sin(time * node.userData.pulseSpeed + node.userData.pulse) * 0.5 + 0.5;
                node.scale.setScalar(1 + pulse * 0.3);
                node.userData.glow.scale.setScalar(1 + pulse * 0.5);
                node.userData.glow.material.opacity = 0.1 + pulse * 0.2;
            });

            // Update connections - highlight when pulse passes
            connections.forEach(conn => {
                conn.material.opacity = conn.userData.baseOpacity;
            });

            // Animate pulses along connections
            pulses.forEach(pulse => {
                pulse.userData.progress += pulse.userData.speed;

                if (pulse.userData.progress >= 1) {
                    pulse.userData.progress = 0;
                    pulse.userData.connection = connections[Math.floor(Math.random() * connections.length)];
                }

                const conn = pulse.userData.connection;
                const nodeA = conn.userData.nodeA.position;
                const nodeB = conn.userData.nodeB.position;

                // Lerp position along connection
                pulse.position.lerpVectors(nodeA, nodeB, pulse.userData.progress);

                // Highlight connection when pulse passes
                conn.material.opacity = Math.max(
                    conn.userData.baseOpacity,
                    1 - Math.abs(pulse.userData.progress - 0.5) * 2
                );

                // Pulse scale
                const pulseScale = Math.sin(pulse.userData.progress * Math.PI);
                pulse.scale.setScalar(0.5 + pulseScale * 0.5);
            });

            // Rotate entire network
            nodeGroup.rotation.x += 0.001;
            nodeGroup.rotation.y += 0.002;

            // Slow rotation of background particles
            bgParticles.rotation.x += 0.0005;
            bgParticles.rotation.y += 0.0003;

            // Camera movement with mouse
            camera.position.x = mouse.centeredX * 8;
            camera.position.y = mouse.centeredY * 8;
            camera.lookAt(0, 0, 0);

            // Orbit camera slowly
            const orbitRadius = 25;
            const orbitX = Math.cos(time * 0.1) * orbitRadius;
            const orbitZ = Math.sin(time * 0.1) * orbitRadius;
            camera.position.x += orbitX * 0.05;
            camera.position.z += orbitZ * 0.05;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>
