<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cosmic Nebula Voyage - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <script type="module">
        import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';

        // --- JaZeR UI schema (injected) ---
        const __jazerEffectFile = location.pathname.split('/').pop() || '';
        const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
        const { ui, expose, ready } = attachEffectUI({
          title: document.title,
          schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
        });
        window.JAZER_UI = ui;
        window.JAZER_EXPOSE = expose;
        window.JAZER_UI_READY = ready;
        // ------------------------------------

        /**
         * ============================================================================
         * COSMIC NEBULA VOYAGE - HIGH-END VISUAL ART
         * ============================================================================
         * CHANGELOG v2.0 - Artistic Upgrade
         * - Constrained palette: Deep violet-blue base + magenta accent + rare warm highlights
         * - Removed 6-color rainbow cycling
         * - Near-still glacial motion - meditative pacing
         * - Reduced star twinkle rate for calmer atmosphere
         * - Removed debug UI overlay for pure visual mode
         * - Camera: Minimal sway, photography-like composition
         * - Finish: Film grain, soft vignette, reduced saturation
         * 
         * THESIS: "Deep space stillness, photographic wonder"
         * ============================================================================
         */

        import { noise3D, mouse } from '../lib/engine/jazer-background-engine.js';
        import '../lib/engine/jazer-navigation.js';
        import * as THREE from '../lib/Three.js';

        window.THREE = THREE;
        const canvas = document.getElementById('c');

        // === COLOR PALETTE (Restrained - Photographic) ===
        const COLORS = {
            deepSpace: new THREE.Color(0x050510),      // Almost black deep space
            nebulaPrimary: new THREE.Color(0x2a1a4a),  // Deep violet
            nebulaSecondary: new THREE.Color(0x4a1a3a),// Magenta undertone
            nebulaAccent: new THREE.Color(0x6a2a5a),   // Rich magenta
            starWarm: new THREE.Color(0xffeedd),       // Warm white stars
            starCool: new THREE.Color(0xaabbff),       // Cool blue stars
            rareTint: new THREE.Color(0xff8866)        // Rare warm highlight
        };

        // === SCENE SETUP ===
        const scene = new THREE.Scene();
        scene.background = COLORS.deepSpace;
        scene.fog = new THREE.FogExp2(0x050510, 0.003);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.85; // Slightly darker for photographic look

        // === VOLUMETRIC NEBULA CLOUDS (Reduced, Harmonized) ===
        const cloudLayers = [];
        const layerCount = 5; // Reduced from 8

        // Palette for clouds - constrained to violet-magenta range
        const cloudPalette = [
            COLORS.nebulaPrimary,
            COLORS.nebulaSecondary,
            COLORS.nebulaAccent,
            COLORS.nebulaSecondary,
            COLORS.nebulaPrimary
        ];

        for (let layer = 0; layer < layerCount; layer++) {
            const cloudParticleCount = 3000; // Reduced from 5000
            const cloudGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(cloudParticleCount * 3);
            const colors = new Float32Array(cloudParticleCount * 3);
            const sizes = new Float32Array(cloudParticleCount);

            const layerColor = cloudPalette[layer % cloudPalette.length];

            for (let i = 0; i < cloudParticleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 15 + Math.random() * 40; // Spread out more

                positions[i * 3] = Math.cos(theta) * Math.sin(phi) * r;
                positions[i * 3 + 1] = Math.sin(theta) * Math.sin(phi) * r;
                positions[i * 3 + 2] = Math.cos(phi) * r - layer * 40 - 60;

                // Subtle color variation within constrained palette
                const variation = 0.15;
                colors[i * 3] = layerColor.r + (Math.random() - 0.5) * variation;
                colors[i * 3 + 1] = layerColor.g + (Math.random() - 0.5) * variation;
                colors[i * 3 + 2] = layerColor.b + (Math.random() - 0.5) * variation;

                sizes[i] = 1.5 + Math.random() * 2.5;
            }

            cloudGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            cloudGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            cloudGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const cloudMat = new THREE.PointsMaterial({
                size: 5,
                vertexColors: true,
                transparent: true,
                opacity: 0.25, // More subtle
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });

            const cloud = new THREE.Points(cloudGeo, cloudMat);
            cloud.userData = {
                layer: layer,
                speed: 0.02 + layer * 0.01, // Slower
                rotationSpeed: 0.00003 + layer * 0.00002 // Much slower rotation
            };

            scene.add(cloud);
            cloudLayers.push(cloud);
        }

        // === STARS (Calmer, Photographic) ===
        const starCount = 2000; // Reduced from 3000
        const starGeo = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);
        const starBaseSizes = new Float32Array(starCount);

        for (let i = 0; i < starCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 400;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 400;
            starPositions[i * 3 + 2] = -Math.random() * 400 - 50;

            // Predominantly cool stars, rare warm ones
            const isWarm = Math.random() < 0.15;
            const starColor = isWarm ? COLORS.starWarm : COLORS.starCool;

            // Desaturate slightly for photographic look
            const desatFactor = 0.7;
            starColors[i * 3] = starColor.r * desatFactor;
            starColors[i * 3 + 1] = starColor.g * desatFactor;
            starColors[i * 3 + 2] = starColor.b * desatFactor;

            const size = 0.3 + Math.random() * 1.5;
            starSizes[i] = size;
            starBaseSizes[i] = size;
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

        const starMat = new THREE.PointsMaterial({
            size: 1.5,
            vertexColors: true,
            transparent: true,
            opacity: 0.85,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // === COSMIC DUST RIBBONS (Refined) ===
        const ribbonCount = 8; // Reduced from 15
        const ribbons = [];

        for (let i = 0; i < ribbonCount; i++) {
            // More controlled, flowing paths
            const startX = (Math.random() - 0.5) * 60;
            const startY = (Math.random() - 0.5) * 40;
            const baseZ = -80 - i * 25;

            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(startX, startY, baseZ),
                new THREE.Vector3(startX + 20, startY + 15, baseZ - 30),
                new THREE.Vector3(startX - 10, startY - 10, baseZ - 60),
                new THREE.Vector3(startX + 15, startY + 5, baseZ - 90)
            ]);

            const tubeGeo = new THREE.TubeGeometry(curve, 80, 0.4, 6, false);

            // Alternate between primary and accent colors
            const ribbonColor = i % 2 === 0 ? COLORS.nebulaPrimary : COLORS.nebulaAccent;

            const tubeMat = new THREE.MeshBasicMaterial({
                color: ribbonColor,
                transparent: true,
                opacity: 0.15, // Very subtle
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });

            const ribbon = new THREE.Mesh(tubeGeo, tubeMat);
            ribbon.userData = {
                speed: 0.03 + Math.random() * 0.02, // Slower
                originalZ: ribbon.position.z
            };

            scene.add(ribbon);
            ribbons.push(ribbon);
        }

        // === ENERGY PLASMA SPHERES (Reduced, Calmer) ===
        const plasmaSpheres = [];
        const plasmaCount = 8; // Reduced from 20

        for (let i = 0; i < plasmaCount; i++) {
            const size = 2 + Math.random() * 4;
            const sphereGeo = new THREE.SphereGeometry(size, 24, 24);

            // Use consistent palette
            const sphereColor = i % 3 === 0 ? COLORS.nebulaAccent :
                i % 3 === 1 ? COLORS.nebulaPrimary : COLORS.nebulaSecondary;

            const sphereMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: sphereColor }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;

                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;

                        vec3 pos = position;
                        // Very subtle distortion
                        float distortion = sin(pos.x * 2.0 + time * 0.3) *
                                          sin(pos.y * 2.0 + time * 0.4) *
                                          sin(pos.z * 2.0 + time * 0.2) * 0.1;
                        pos += normal * distortion;

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec3 vNormal;
                    varying vec3 vPosition;

                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.5);
                        // Slow, subtle pulse
                        float pulse = sin(time * 0.5) * 0.15 + 0.85;
                        vec3 glowColor = color * (fresnel * pulse);
                        gl_FragColor = vec4(glowColor, fresnel * 0.4);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });

            const plasma = new THREE.Mesh(sphereGeo, sphereMat);
            plasma.position.set(
                (Math.random() - 0.5) * 80,
                (Math.random() - 0.5) * 80,
                -Math.random() * 250 - 80
            );
            plasma.userData = {
                speed: 0.02 + Math.random() * 0.03, // Much slower
                rotationSpeed: (Math.random() - 0.5) * 0.005 // Slower rotation
            };

            scene.add(plasma);
            plasmaSpheres.push(plasma);
        }

        // === ANIMATION STATE ===
        let time = 0;
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;

            time += deltaTime;
            mouse.update();

            // Glacial camera movement - very slow forward drift
            camera.position.z -= 0.03; // Much slower than before

            // Animate nebula cloud layers - minimal rotation
            cloudLayers.forEach(cloud => {
                cloud.rotation.y += cloud.userData.rotationSpeed;
                cloud.rotation.z += cloud.userData.rotationSpeed * 0.3;

                // Very subtle noise-based movement
                const pos = cloud.geometry.attributes.position.array;
                for (let i = 0; i < pos.length / 3; i++) {
                    const idx = i * 3;
                    const noiseVal = noise3D(
                        pos[idx] * 0.02,
                        pos[idx + 1] * 0.02,
                        time * 0.03 + cloud.userData.layer
                    );

                    pos[idx] += Math.sin(noiseVal + time * 0.2) * 0.005;
                    pos[idx + 1] += Math.cos(noiseVal + time * 0.2) * 0.005;
                }
                cloud.geometry.attributes.position.needsUpdate = true;

                // Recycle clouds that pass the camera
                if (camera.position.z < cloud.position.z - 150) {
                    cloud.position.z = camera.position.z - 350;
                }
            });

            // Gentle star twinkle - much slower rate
            const starSizeArray = stars.geometry.attributes.size.array;
            for (let i = 0; i < starSizeArray.length; i++) {
                // Slow, subtle size variation
                const twinkle = Math.sin(time * 0.5 + i * 0.1) * 0.1 + 1;
                starSizeArray[i] = starBaseSizes[i] * twinkle;
            }
            stars.geometry.attributes.size.needsUpdate = true;

            // Move ribbons - very slow drift
            ribbons.forEach(ribbon => {
                ribbon.position.z += ribbon.userData.speed;
                if (ribbon.position.z > camera.position.z + 60) {
                    ribbon.position.z = camera.position.z - 350;
                }
            });

            // Animate plasma spheres - glacial movement
            plasmaSpheres.forEach(plasma => {
                plasma.rotation.y += plasma.userData.rotationSpeed;
                plasma.material.uniforms.time.value = time;
                plasma.position.z += plasma.userData.speed;

                if (plasma.position.z > camera.position.z + 80) {
                    plasma.position.z = camera.position.z - 350;
                    plasma.position.x = (Math.random() - 0.5) * 80;
                    plasma.position.y = (Math.random() - 0.5) * 80;
                }
            });

            // Camera sway - minimal, photography-like
            camera.position.x = mouse.centeredX * 3; // Reduced from 10
            camera.position.y = mouse.centeredY * 3;
            camera.lookAt(camera.position.x * 0.05, camera.position.y * 0.05, camera.position.z - 150);

            renderer.render(scene, camera);
        }

        // === RESIZE HANDLER ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // === START ANIMATION ===
        animate();
    </script>
</body>

</html>