<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sri Yantra Vortex - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        .watermark {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.08);
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <div class="watermark">JaZeR</div>
    <script type="module">
        import {
            noise2D, mouse,
            ColorPalettes, hexToRgb,
            smoothstep
        } from '../lib/jazer-background-engine.js';

        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        let W, H, cx, cy;
        let time = 0;

        // Warm sacred colors
        const palette = ['#ff6b00', '#ff2a6d', '#d946ef', '#f97316', '#fbbf24'];
        const layerCount = 8;

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            cx = W / 2;
            cy = H / 2;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // Draw interlocking triangles (simplified Sri Yantra)
        function drawSriYantra(x, y, radius, rotation, alpha, colorOffset) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.globalCompositeOperation = 'lighter';

            // Outer circle
            const rgb0 = hexToRgb(palette[Math.floor(colorOffset) % palette.length]);
            ctx.strokeStyle = `rgba(${rgb0.r}, ${rgb0.g}, ${rgb0.b}, ${alpha * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.stroke();

            // 9 interlocking triangles (4 upward, 5 downward - simplified)
            const triangleSizes = [0.95, 0.8, 0.65, 0.5, 0.35, 0.22, 0.12];

            triangleSizes.forEach((size, i) => {
                const r = radius * size;
                const isUpward = i % 2 === 0;
                const colorIdx = Math.floor((colorOffset + i * 0.7) % palette.length);
                const color = palette[colorIdx];
                const rgb = hexToRgb(color);

                const triAlpha = alpha * (0.9 - i * 0.08);
                ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${triAlpha})`;
                ctx.lineWidth = 1.5;

                ctx.beginPath();
                for (let j = 0; j <= 3; j++) {
                    const angle = (j / 3) * Math.PI * 2 + (isUpward ? -Math.PI / 2 : Math.PI / 2);
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();

                // Glow fill
                ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${triAlpha * 0.1})`;
                ctx.fill();
            });

            // Central bindu (point)
            const binduColor = palette[Math.floor((colorOffset + time) % palette.length)];
            const binduRgb = hexToRgb(binduColor);

            const binduGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.15);
            binduGlow.addColorStop(0, `rgba(${binduRgb.r}, ${binduRgb.g}, ${binduRgb.b}, ${alpha})`);
            binduGlow.addColorStop(0.5, `rgba(${binduRgb.r}, ${binduRgb.g}, ${binduRgb.b}, ${alpha * 0.3})`);
            binduGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = binduGlow;
            ctx.fillRect(-radius * 0.15, -radius * 0.15, radius * 0.3, radius * 0.3);

            ctx.restore();
        }

        class VortexLayer {
            constructor(index) {
                this.index = index;
                this.z = index * 0.25;
                this.rotationDir = index % 2 === 0 ? 1 : -1;
                this.colorOffset = index * 0.6;
            }

            update(dt) {
                this.z += dt * 0.05; // Very slow and meditative
                if (this.z > 2) {
                    this.z = 0;
                    this.colorOffset = Math.random() * palette.length;
                }
            }

            draw() {
                const scale = 1 / (1 + this.z * 1.8);
                const alpha = smoothstep(0, 0.5, this.z) * smoothstep(2, 1.2, this.z);

                if (alpha < 0.01) return;

                const radius = 150 * scale;
                const rotation = time * 0.05 * this.rotationDir + this.index * 0.4;

                const parallax = this.z * 0.35;
                const offsetX = mouse.centeredX * 60 * parallax;
                const offsetY = mouse.centeredY * 60 * parallax;

                drawSriYantra(cx + offsetX, cy + offsetY, radius, rotation, alpha, this.colorOffset);
            }
        }

        const layers = Array.from({ length: layerCount }, (_, i) => new VortexLayer(i));

        function render() {
            time += 1 / 60;
            mouse.update();

            // Deep warm background
            const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H) * 0.7);
            bgGrad.addColorStop(0, '#150808');
            bgGrad.addColorStop(1, '#050002');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            // Very slow fade
            ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
            ctx.fillRect(0, 0, W, H);

            const dt = 1 / 60;

            layers.sort((a, b) => b.z - a.z);
            layers.forEach(l => { l.update(dt); l.draw(); });

            // Warm center glow
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 180);
            glow.addColorStop(0, 'rgba(255, 107, 0, 0.1)');
            glow.addColorStop(0.4, 'rgba(217, 70, 239, 0.05)');
            glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = glow;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();

            // Vignette
            const vig = ctx.createRadialGradient(cx, cy, Math.min(W, H) * 0.35, cx, cy, Math.max(W, H) * 0.7);
            vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vig.addColorStop(1, 'rgba(0, 0, 0, 0.7)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);

            requestAnimationFrame(render);
        }

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(render);
    </script>
</body>

</html>