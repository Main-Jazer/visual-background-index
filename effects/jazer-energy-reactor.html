<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Energy Reactor Core - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';

        // --- JaZeR UI schema (injected) ---
        const __jazerEffectFile = location.pathname.split('/').pop() || '';
        const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
        const { ui, expose, ready } = attachEffectUI({
          title: document.title,
          schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
        });
        window.JAZER_UI = ui;
        window.JAZER_EXPOSE = expose;
        window.JAZER_UI_READY = ready;
        // ------------------------------------

        /**
         * ============================================================================
         * ENERGY REACTOR CORE - HIGH-END VISUAL ART
         * ============================================================================
         * CHANGELOG v2.0 - Artistic Upgrade
         * - Constrained palette: Hot orange-red core + cool blue containment + white peaks
         * - Removed 6-color rainbow cycling
         * - Added heartbeat rhythm: 5-second charge → sustain → release cycle
         * - Reduced particle count for cleaner composition
         * - Established visual hierarchy: Core (primary), rings (secondary), particles (ambient)
         * - Plasma arcs fire in sync with heartbeat, not randomly
         * - Camera: Static with subtle breathing, reactor-centered
         * - Finish: High contrast, warmer core temperature, cooler edges
         * 
         * THESIS: "Contained power in equilibrium, heartbeat of controlled fusion"
         * ============================================================================
         */

        import { mouse } from '../lib/engine/jazer-background-engine.js';
        import '../lib/engine/jazer-navigation.js';
        import * as THREE from '../lib/Three.js';
        window.THREE = THREE;
        const canvas = document.getElementById('c');

        // === COLOR PALETTE (Restrained) ===
        const COLORS = {
            coreHot: new THREE.Color(0xff4400),    // Hot orange core
            coreWarm: new THREE.Color(0xff6622),   // Warm orange
            coolBlue: new THREE.Color(0x0088cc),   // Containment blue
            coolCyan: new THREE.Color(0x00aadd),   // Secondary blue
            white: new THREE.Color(0xffffff),      // Energy peaks
            darkBlue: new THREE.Color(0x001122)    // Background
        };

        // === HEARTBEAT PARAMETERS ===
        const HEARTBEAT_PERIOD = 5; // 5-second full cycle
        let heartbeatPhase = 0;

        // Heartbeat shape function: charge → peak → release → rest
        function getHeartbeat(t) {
            const normalized = (t % HEARTBEAT_PERIOD) / HEARTBEAT_PERIOD;
            // Sharp peak at 0.3, gradual decay
            if (normalized < 0.3) {
                return Math.pow(normalized / 0.3, 2); // Charge
            } else if (normalized < 0.4) {
                return 1.0; // Sustain peak
            } else {
                return Math.pow(1 - (normalized - 0.4) / 0.6, 1.5); // Release
            }
        }

        // === SCENE SETUP ===
        const scene = new THREE.Scene();
        scene.background = COLORS.darkBlue;
        scene.fog = new THREE.FogExp2(0x001122, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;

        // === CENTRAL CORE (Primary Focus) ===
        const coreGeo = new THREE.SphereGeometry(1.8, 48, 48);
        const coreMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                heartbeat: { value: 0 },
                coreColor: { value: COLORS.coreHot },
                warmColor: { value: COLORS.coreWarm }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                uniform float time;
                uniform float heartbeat;

                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;

                    vec3 pos = position;
                    // Subtle surface distortion, more during heartbeat peak
                    float distortionStrength = 0.05 + heartbeat * 0.1;
                    float distortion = sin(pos.x * 4.0 + time * 2.0) *
                                      sin(pos.y * 4.0 + time * 2.0) *
                                      sin(pos.z * 4.0 + time * 2.0) * distortionStrength;
                    pos += normal * distortion;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float heartbeat;
                uniform vec3 coreColor;
                uniform vec3 warmColor;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.5);
                    
                    // Core color varies with heartbeat
                    vec3 color = mix(warmColor, coreColor, heartbeat);
                    
                    // Add white hot center during peak
                    color = mix(color, vec3(1.0), heartbeat * fresnel * 0.3);
                    
                    // Intensity follows heartbeat
                    float intensity = 0.6 + heartbeat * 0.8;
                    vec3 finalColor = color * intensity;

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            blending: THREE.AdditiveBlending
        });

        const core = new THREE.Mesh(coreGeo, coreMat);
        scene.add(core);

        // === INNER GLOW SHELL ===
        const shellGeo = new THREE.SphereGeometry(2.2, 32, 32);
        const shellMat = new THREE.MeshBasicMaterial({
            color: COLORS.coreWarm,
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide
        });
        const shell = new THREE.Mesh(shellGeo, shellMat);
        scene.add(shell);

        // === CONTAINMENT RINGS (Secondary) ===
        const rings = [];
        for (let i = 0; i < 3; i++) {
            const ringGeo = new THREE.TorusGeometry(3.5 + i * 0.6, 0.08, 16, 100);
            const ringMat = new THREE.MeshBasicMaterial({
                color: COLORS.coolBlue,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });

            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2 + (i * Math.PI / 6);
            ring.rotation.y = i * Math.PI / 4;
            ring.userData = {
                baseRotationX: ring.rotation.x,
                baseRotationY: ring.rotation.y,
                speedX: 0.003 + i * 0.002,
                speedY: 0.002 + i * 0.001
            };

            scene.add(ring);
            rings.push(ring);
        }

        // === AMBIENT PARTICLES (Reduced count) ===
        const particleCount = 1500; // Reduced from 5000
        const particleGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const velocities = [];

        for (let i = 0; i < particleCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const r = 3 + Math.random() * 6;

            positions[i * 3] = Math.cos(theta) * Math.sin(phi) * r;
            positions[i * 3 + 1] = Math.sin(theta) * Math.sin(phi) * r;
            positions[i * 3 + 2] = Math.cos(phi) * r;

            // Gradient from warm near core to cool at edges
            const t = (r - 3) / 6;
            const color = COLORS.coreWarm.clone().lerp(COLORS.coolCyan, t);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;

            velocities.push({
                theta: (Math.random() - 0.5) * 0.015,
                phi: (Math.random() - 0.5) * 0.008
            });
        }

        particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particleMat = new THREE.PointsMaterial({
            size: 0.12,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);

        // === PLASMA ARCS (Synchronized with heartbeat) ===
        const arcCount = 8; // Reduced from 30
        const arcs = [];

        for (let i = 0; i < arcCount; i++) {
            const angle = (i / arcCount) * Math.PI * 2;
            const points = [];
            const segments = 15;

            for (let j = 0; j <= segments; j++) {
                const t = j / segments;
                const radius = 2 + t * 2.5;
                const x = Math.cos(angle + t * 0.5) * radius;
                const y = Math.sin(angle + t * 0.5) * radius;
                const z = (Math.random() - 0.5) * 1.5;
                points.push(new THREE.Vector3(x, y, z));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            const arcGeo = new THREE.TubeGeometry(curve, 20, 0.04, 6, false);
            const arcMat = new THREE.MeshBasicMaterial({
                color: COLORS.white,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });

            const arc = new THREE.Mesh(arcGeo, arcMat);
            arc.userData = { phaseOffset: i / arcCount };
            scene.add(arc);
            arcs.push(arc);
        }

        // === REACTOR CHAMBER (Subtle) ===
        const chamberGeo = new THREE.CylinderGeometry(8, 8, 16, 6, 1, true);
        const chamberEdges = new THREE.EdgesGeometry(chamberGeo);
        const chamberMat = new THREE.LineBasicMaterial({
            color: COLORS.coolBlue,
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending
        });
        const chamber = new THREE.LineSegments(chamberEdges, chamberMat);
        scene.add(chamber);

        // === ANIMATION STATE ===
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);

            const dt = 0.016;
            time += dt;

            // Calculate heartbeat
            const heartbeat = getHeartbeat(time);

            mouse.update();

            // Update core
            coreMat.uniforms.time.value = time;
            coreMat.uniforms.heartbeat.value = heartbeat;
            core.rotation.y += 0.003;

            // Scale core with heartbeat
            const coreScale = 1 + heartbeat * 0.15;
            core.scale.setScalar(coreScale);

            // Shell pulses with heartbeat
            const shellScale = 1 + heartbeat * 0.1;
            shell.scale.setScalar(shellScale);
            shellMat.opacity = 0.1 + heartbeat * 0.15;

            // Rotate containment rings (slow, steady)
            rings.forEach((ring, i) => {
                ring.rotation.x = ring.userData.baseRotationX + time * ring.userData.speedX;
                ring.rotation.y = ring.userData.baseRotationY + time * ring.userData.speedY;

                // Subtle brightness pulse with heartbeat
                ring.material.opacity = 0.4 + heartbeat * 0.2;
            });

            // Plasma arcs fire during heartbeat peaks
            arcs.forEach((arc, i) => {
                const arcPhase = (time / HEARTBEAT_PERIOD + arc.userData.phaseOffset) % 1;
                // Arcs visible only during peak phase (0.25 - 0.45)
                if (arcPhase > 0.25 && arcPhase < 0.45) {
                    arc.material.opacity = Math.sin((arcPhase - 0.25) / 0.2 * Math.PI) * 0.8;
                } else {
                    arc.material.opacity = 0;
                }
            });

            // Swirl particles (slower)
            const pos = particleGeo.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;
                const x = pos[idx];
                const y = pos[idx + 1];
                const z = pos[idx + 2];

                let r = Math.sqrt(x * x + y * y + z * z);
                let theta = Math.atan2(y, x);
                let phi = Math.acos(z / r);

                // Slow swirl
                theta += velocities[i].theta * (0.5 + heartbeat * 0.5);
                phi += velocities[i].phi * (0.5 + heartbeat * 0.5);

                // Subtle pulse radius with heartbeat
                r += Math.sin(time * 0.5 + i * 0.01) * 0.02 * (1 + heartbeat);

                r = Math.max(3, Math.min(9, r));

                pos[idx] = Math.cos(theta) * Math.sin(phi) * r;
                pos[idx + 1] = Math.sin(theta) * Math.sin(phi) * r;
                pos[idx + 2] = Math.cos(phi) * r;
            }
            particleGeo.attributes.position.needsUpdate = true;

            // Particle opacity follows heartbeat
            particleMat.opacity = 0.4 + heartbeat * 0.3;

            // Chamber subtle rotation
            chamber.rotation.y += 0.0005;
            chamberMat.opacity = 0.1 + heartbeat * 0.08;

            // === CAMERA: Static with subtle breathing ===
            camera.position.x = mouse.centeredX * 2;
            camera.position.y = mouse.centeredY * 2;
            camera.position.z = 15 + Math.sin(time * 0.1) * 0.5;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>