<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JaZeR Anamorphic Logo Waves</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: radial-gradient(circle at 50% 20%, #050516, #010108 70%);
      color: #f5f7ff;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    .label {
      position: fixed;
      right: 2rem;
      bottom: 2rem;
      font-size: 0.8rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.45);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="effectCanvas"></canvas>
  <div class="label">Anamorphic Logo Waves</div>
  <script type="module">
    import * as THREE from '../lib/Three.js';
    import { mouse } from '../lib/jazer-background-engine.js';

    const canvas = document.getElementById('effectCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x02020a, 1);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x02020a, 0.05);

    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 200);
    camera.position.set(0, 3, 7);
    camera.lookAt(0, 0, 0);

    const gridGeometry = new THREE.PlaneGeometry(16, 10, 280, 160);

    function createLogoTexture() {
      const texCanvas = document.createElement('canvas');
      texCanvas.width = 1024;
      texCanvas.height = 256;
      const ctx = texCanvas.getContext('2d');
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, texCanvas.width, texCanvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.font = '190px "Inter", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('JAZER', texCanvas.width / 2, texCanvas.height * 0.55);
      const texture = new THREE.CanvasTexture(texCanvas);
      texture.flipY = false;
      return texture;
    }

    const logoTexture = createLogoTexture();

    const gridVertex = /* glsl */`
      varying vec2 vUv;
      varying float vHeight;
      uniform float uTime;
      uniform sampler2D uLogo;
      uniform vec2 uMouse;

      vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
      float snoise(vec3 v){
        const vec2  C = vec2(1.0/6.0, 1.0/3.0);
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 =   v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod(i, 289.0);
        vec4 p = permute( permute( permute(
                  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        float n_ = 1.0/7.0;
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
        vec3 g0 = vec3(a0.xy,h.x);
        vec3 g1 = vec3(a0.zw,h.y);
        vec3 g2 = vec3(a1.xy,h.z);
        vec3 g3 = vec3(a1.zw,h.w);
        vec4 norm = inversesqrt(vec4(dot(g0,g0), dot(g1,g1), dot(g2,g2), dot(g3,g3)));
        g0 *= norm.x;
        g1 *= norm.y;
        g2 *= norm.z;
        g3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4( dot(g0,x0), dot(g1,x1),
                                      dot(g2,x2), dot(g3,x3) ));
      }

      void main() {
        vUv = uv;
        vec3 pos = position;
        float wave = sin(uv.x * 60.0 + uTime * 1.6) * 0.2;
        wave += snoise(vec3(uv * 6.0, uTime * 0.45)) * 0.4;
        float imprint = texture(uLogo, vec2(uv.x, 1.0 - uv.y)).r;
        float anamorph = smoothstep(0.6, 0.95, imprint);
        pos.z += wave - anamorph * 0.9;
        pos.x += uMouse.x * (pos.z * 0.08);
        pos.y += uMouse.y * (pos.z * 0.05);
        vHeight = pos.z;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    const gridFragment = /* glsl */`
      varying vec2 vUv;
      varying float vHeight;
      uniform float uTime;
      uniform sampler2D uLogo;

      float gridLine(float v, float scale) {
        return smoothstep(0.0, 0.02, abs(fract(v * scale) - 0.5));
      }

      void main() {
        vec3 base = mix(vec3(0.0, 0.1, 0.2), vec3(0.9, 0.2, 0.8), vUv.x);
        float gridX = gridLine(vUv.x, 40.0);
        float gridY = gridLine(vUv.y, 18.0);
        float glow = exp(-abs(vHeight) * 1.5);
        float imprint = texture(uLogo, vec2(vUv.x, 1.0 - vUv.y)).r;
        float reveal = smoothstep(0.45, 0.7, imprint) * smoothstep(-0.2, 0.6, vHeight);
        vec3 color = base;
        color += vec3(0.2, 0.5, 1.0) * (gridX + gridY) * 0.25;
        color += vec3(1.0, 0.35, 0.8) * reveal * 1.4;
        color += vec3(0.05, 0.2, 0.8) * glow;
        float alpha = 0.8 + reveal * 0.2;
        gl_FragColor = vec4(color, alpha);
      }
    `;

    const gridMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uLogo: { value: logoTexture },
        uMouse: { value: new THREE.Vector2() }
      },
      vertexShader: gridVertex,
      fragmentShader: gridFragment,
      transparent: true,
      side: THREE.DoubleSide
    });

    const grid = new THREE.Mesh(gridGeometry, gridMaterial);
    grid.rotation.x = -Math.PI / 3;
    grid.position.y = -1;
    scene.add(grid);

    const crestGeometry = new THREE.BufferGeometry();
    const crestCount = 160;
    const crestPositions = new Float32Array(crestCount * 3);
    const crestOffsets = new Float32Array(crestCount);
    for (let i = 0; i < crestCount; i++) {
      crestPositions.set([ (Math.random() - 0.5) * 12, (Math.random() - 0.3) * 4, -Math.random() * 6 ], i * 3);
      crestOffsets[i] = Math.random() * Math.PI * 2;
    }
    crestGeometry.setAttribute('position', new THREE.BufferAttribute(crestPositions, 3));
    crestGeometry.setAttribute('offset', new THREE.BufferAttribute(crestOffsets, 1));
    const crestMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 }
      },
      vertexShader: /* glsl */`
        attribute float offset;
        uniform float uTime;
        varying float vAlpha;
        void main() {
          vec3 pos = position;
          pos.y += sin(uTime * 2.0 + offset) * 0.2;
          vAlpha = fract(offset);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = 30.0 / gl_Position.w;
        }
      `,
      fragmentShader: /* glsl */`
        varying float vAlpha;
        void main() {
          float dist = length(gl_PointCoord - 0.5);
          float alpha = smoothstep(0.5, 0.0, dist) * (0.4 + 0.6 * vAlpha);
          gl_FragColor = vec4(0.6, 0.9, 1.0, alpha);
        }
      `,
      blending: THREE.AdditiveBlending,
      transparent: true,
      depthWrite: false
    });
    const crests = new THREE.Points(crestGeometry, crestMaterial);
    scene.add(crests);

    const clock = new THREE.Clock();

    function resize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resize);
    resize();

    function animate() {
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();
      mouse.update();

      gridMaterial.uniforms.uTime.value = elapsed;
      gridMaterial.uniforms.uMouse.value.set(mouse.centeredX, mouse.centeredY);
      crestMaterial.uniforms.uTime.value = elapsed;

      grid.rotation.z = Math.sin(elapsed * 0.2) * 0.06 + mouse.centeredX * 0.1;
      camera.position.x = Math.sin(elapsed * 0.2) * 0.4 + mouse.centeredX * 0.6;
      camera.position.y = 3 + Math.sin(elapsed * 0.3) * 0.2;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
