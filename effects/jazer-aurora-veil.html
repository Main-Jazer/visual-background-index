<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JaZeR Aurora Veil</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: radial-gradient(circle at 50% 0%, #071022, #010208 70%);
      color: #eff6ff;
      overflow: hidden;
      min-height: 100vh;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .label {
      position: fixed;
      top: 2rem;
      left: 2rem;
      letter-spacing: 0.4em;
      text-transform: uppercase;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.45);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="effect"></canvas>
  <div class="label">Aurora Veil</div>
  <script type="module">
    import { mouse, noise2D, ColorPalettes } from '../lib/jazer-background-engine.js';

    const canvas = document.getElementById('effect');
    const ctx = canvas.getContext('2d');
    const palette = ColorPalettes.aurora || ColorPalettes.vapor || ColorPalettes.jazer;

    const RIBBON_COUNT = 5;
    const POINTS = 90;
    const STAR_COUNT = 160;
    const SHARD_COUNT = 60;

    const ribbons = [];
    const stars = [];
    const shards = [];

    let width = 0;
    let height = 0;
    let lastTime = 0;
    let time = 0;

    class Ribbon {
      constructor(index) {
        this.index = index;
        this.points = Array.from({ length: POINTS }, () => ({ x: 0, y: 0 }));
        this.offset = Math.random() * 1000;
        this.color = palette[(index + 1) % palette.length] || '#7cf2ff';
      }

      update(dt) {
        this.offset += dt * 0.4;
        const baseHeight = height * (0.25 + this.index * 0.12);
        const amplitude = 60 + this.index * 25;

        for (let i = 0; i < POINTS; i++) {
          const progress = i / (POINTS - 1);
          const wave = Math.sin(progress * 12 - time * 1.3 + this.index) * amplitude * 0.6;
          const sway = noise2D(progress * 2 + this.index, time * 0.35 + this.offset) * amplitude;
          this.points[i].x = progress;
          this.points[i].y = baseHeight + wave + sway + mouse.centeredY * 35;
        }
      }

      draw() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        const gradient = ctx.createLinearGradient(0, Math.min(...this.points.map(p => p.y)) - 120, 0, Math.max(...this.points.map(p => p.y)) + 120);
        gradient.addColorStop(0, `${this.color}05`);
        gradient.addColorStop(0.5, `${this.color}cc`);
        gradient.addColorStop(1, `${this.color}05`);
        ctx.fillStyle = gradient;

        ctx.beginPath();
        this.points.forEach((point, idx) => {
          const x = point.x * width + (point.x - 0.5) * mouse.centeredX * 120;
          const y = point.y;
          if (idx === 0) {
            ctx.moveTo(x, y - 50);
          } else {
            ctx.lineTo(x, y - 50);
          }
        });
        for (let i = this.points.length - 1; i >= 0; i--) {
          const point = this.points[i];
          const x = point.x * width + (point.x - 0.5) * mouse.centeredX * 120;
          const y = point.y;
          ctx.lineTo(x, y + 50);
        }
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = `${this.color}aa`;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        this.points.forEach((point, idx) => {
          const x = point.x * width + (point.x - 0.5) * mouse.centeredX * 120;
          const y = point.y;
          if (idx === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();

        ctx.restore();
      }
    }

    class Star {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.speed = 8 + Math.random() * 20;
        this.alpha = 0.15 + Math.random() * 0.4;
        this.size = 1 + Math.random() * 2;
      }

      update(dt) {
        this.y += dt * this.speed;
        if (this.y > height) {
          this.y = -10;
          this.x = Math.random() * width;
        }
      }

      draw() {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
      }
    }

    class LightShard {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * width;
        this.y = height * (0.4 + Math.random() * 0.5);
        this.length = 50 + Math.random() * 80;
        this.speed = 30 + Math.random() * 40;
        this.angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.3;
        this.alpha = 0.05 + Math.random() * 0.1;
        this.color = palette[Math.floor(Math.random() * palette.length)] || '#9be8ff';
      }

      update(dt) {
        this.x += Math.cos(this.angle) * this.speed * dt;
        this.y += Math.sin(this.angle) * this.speed * dt;
        if (this.y < -100 || this.x < -100 || this.x > width + 100) {
          this.reset();
        }
      }

      draw() {
        ctx.strokeStyle = `${this.color}${Math.floor(this.alpha * 255).toString(16).padStart(2, '0')}`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(this.angle) * this.length, this.y + Math.sin(this.angle) * this.length);
        ctx.stroke();
      }
    }

    function setup() {
      for (let i = 0; i < RIBBON_COUNT; i++) {
        ribbons.push(new Ribbon(i));
      }
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push(new Star());
      }
      for (let i = 0; i < SHARD_COUNT; i++) {
        shards.push(new LightShard());
      }
      resize();
      requestAnimationFrame(render);
    }

    function resize() {
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener('resize', resize);

    function render(now) {
      const dt = (now - lastTime) / 1000 || 0;
      lastTime = now;
      time += dt;
      mouse.update();

      ctx.clearRect(0, 0, width, height);
      drawBackground();

      stars.forEach(star => {
        star.update(dt);
        star.draw();
      });

      shards.forEach(shard => {
        shard.update(dt);
        shard.draw();
      });

      ribbons.forEach(ribbon => {
        ribbon.update(dt);
        ribbon.draw();
      });

      drawGroundGlow();
      drawMist();

      requestAnimationFrame(render);
    }

    function drawBackground() {
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#0a1022');
      gradient.addColorStop(0.6, '#030414');
      gradient.addColorStop(1, '#000000');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }

    function drawGroundGlow() {
      const glow = ctx.createRadialGradient(width / 2, height * 0.95, 0, width / 2, height, height * 0.6);
      glow.addColorStop(0, 'rgba(0, 255, 214, 0.2)');
      glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, width, height);
    }

    function drawMist() {
      ctx.save();
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = '#0b1224';
      for (let y = 0; y < height; y += 4) {
        ctx.fillRect(0, y, width, 1);
      }
      ctx.restore();
    }

    setup();
  </script>
</body>
</html>
