<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JaZeR Aurora Veil</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: radial-gradient(circle at 50% 0%, #050b22, #01030a 70%);
      color: #f8fbff;
      overflow: hidden;
      min-height: 100vh;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    .label {
      position: fixed;
      left: 2rem;
      top: 2rem;
      text-transform: uppercase;
      letter-spacing: 0.4em;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.45);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="effectCanvas"></canvas>
  <div class="label">Aurora Veil</div>
  <script type="module">
    import * as THREE from '../lib/Three.js';
        import '../lib/engine/jazer-navigation.js';
    import { mouse } from '../lib/engine/jazer-background-engine.js';
    import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';
    // --- JaZeR UI schema (injected) ---
    const __jazerEffectFile = location.pathname.split('/').pop() || '';
    const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
    const { ui, expose, ready } = attachEffectUI({
      title: document.title,
      schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
    });
    window.JAZER_UI = ui;
    window.JAZER_EXPOSE = expose;
    window.JAZER_UI_READY = ready;
    // ------------------------------------


    const canvas = document.getElementById('effectCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x01020a, 1);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020313, 0.06);

    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 200);
    camera.position.set(0, 2, 8);

    const auroraColors = [0x7cf2ff, 0x44ffd2, 0xff5bf7, 0x64a1ff, 0x27c4ff];

    const ribbonVertex = /* glsl */`
      uniform float uTime;
      uniform float uOffset;
      uniform vec2 uMouse;
      varying float vAlpha;
      varying vec3 vColor;

      vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
      float snoise(vec3 v){
        const vec2  C = vec2(1.0/6.0, 1.0/3.0);
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 =   v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod(i, 289.0);
        vec4 p = permute( permute( permute(
                  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        float n_ = 1.0/7.0;
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
        vec3 g0 = vec3(a0.xy,h.x);
        vec3 g1 = vec3(a0.zw,h.y);
        vec3 g2 = vec3(a1.xy,h.z);
        vec3 g3 = vec3(a1.zw,h.w);
        vec4 norm = inversesqrt(vec4(dot(g0,g0), dot(g1,g1), dot(g2,g2), dot(g3,g3)));
        g0 *= norm.x; g1 *= norm.y; g2 *= norm.z; g3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4( dot(g0,x0), dot(g1,x1),
                                      dot(g2,x2), dot(g3,x3) ));
      }

      void main() {
        vec3 pos = position;
        float noiseWave = snoise(vec3(pos.x * 0.15 + uOffset, pos.y * 0.05, uTime * 0.15));
        pos.y += noiseWave * 1.4;
        pos.z += sin(pos.x * 0.5 + uTime * 0.6 + uOffset) * 0.5;
        pos.x += uMouse.x * pos.y * 0.05;
        pos.z += uMouse.y * 0.2;
        vAlpha = smoothstep(0.0, 1.0, position.y * 0.5 + 0.5);
        vColor = vec3(0.4 + uOffset * 0.6, 0.8 - uOffset * 0.4, 1.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    const ribbonFragment = /* glsl */`
      varying float vAlpha;
      varying vec3 vColor;
      void main() {
        float alpha = smoothstep(0.0, 0.4, vAlpha) * 0.9;
        gl_FragColor = vec4(vColor, alpha);
      }
    `;

    const ribbons = [];
    for (let i = 0; i < 5; i++) {
      const geometry = new THREE.PlaneGeometry(12, 3, 120, 16);
      geometry.translate(0, i * 0.8, -i * 0.4);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uOffset: { value: i * 0.35 },
          uMouse: { value: new THREE.Vector2() }
        },
        vertexShader: ribbonVertex,
        fragmentShader: ribbonFragment,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.z = -i * 0.5;
      scene.add(mesh);
      ribbons.push(mesh);
    }

    const shardCount = 220;
    const shardGeometry = new THREE.BufferGeometry();
    const shardPositions = new Float32Array(shardCount * 3);
    const shardSpeeds = new Float32Array(shardCount);
    for (let i = 0; i < shardCount; i++) {
      shardPositions[i * 3] = (Math.random() - 0.5) * 20;
      shardPositions[i * 3 + 1] = Math.random() * 8;
      shardPositions[i * 3 + 2] = -Math.random() * 20;
      shardSpeeds[i] = 5 + Math.random() * 10;
    }
    shardGeometry.setAttribute('position', new THREE.BufferAttribute(shardPositions, 3));
    const shardMaterial = new THREE.PointsMaterial({
      size: 0.08,
      color: 0xffffff,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const shards = new THREE.Points(shardGeometry, shardMaterial);
    scene.add(shards);

    const starGeometry = new THREE.BufferGeometry();
    const starCount = 600;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      starPositions[i * 3] = (Math.random() - 0.5) * 80;
      starPositions[i * 3 + 1] = Math.random() * 30 - 5;
      starPositions[i * 3 + 2] = -Math.random() * 80;
    }
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMaterial = new THREE.PointsMaterial({
      size: 0.05,
      color: 0x9bdfff,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    const groundGeo = new THREE.PlaneGeometry(60, 60);
    const groundMat = new THREE.MeshBasicMaterial({
      color: 0x02030b,
      transparent: true,
      opacity: 0.7,
      side: THREE.DoubleSide
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -3;
    scene.add(ground);

    const clock = new THREE.Clock();

    function resize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resize);
    resize();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();
      mouse.update();

      ribbons.forEach((ribbon, index) => {
        ribbon.material.uniforms.uTime.value = elapsed + index * 10;
        ribbon.material.uniforms.uMouse.value.set(mouse.centeredX, mouse.centeredY);
      });

      const positions = shardGeometry.attributes.position.array;
      for (let i = 0; i < shardCount; i++) {
        positions[i * 3 + 1] += shardSpeeds[i] * delta;
        positions[i * 3 + 0] += mouse.centeredX * delta * 4;
        if (positions[i * 3 + 1] > 10) {
          positions[i * 3 + 1] = Math.random() * 2 - 4;
          positions[i * 3 + 2] = -Math.random() * 20;
        }
      }
      shardGeometry.attributes.position.needsUpdate = true;

      camera.position.x = Math.sin(elapsed * 0.1) * 0.8 + mouse.centeredX * 1.2;
      camera.position.y = 2.2 + Math.sin(elapsed * 0.2) * 0.3 + mouse.centeredY * 0.6;
      camera.lookAt(0, 1, -5);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
