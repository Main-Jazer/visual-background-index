<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Metatron's Cube Vortex - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        .watermark {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.08);
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <div class="watermark">JaZeR</div>
    <script type="module">
        import {
            noise2D, mouse,
            ColorPalettes, hexToRgb, lerpColor,
            map, smoothstep
        } from '../jazer-background-engine.js';

        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        let W, H, cx, cy;
        let time = 0;

        const palette = ['#00f5ff', '#b37cff', '#ff2aff', '#ffd86b', '#00ff88'];
        const layerCount = 10;

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            cx = W / 2;
            cy = H / 2;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // Metatron's Cube vertices (13 circles: 1 center, 6 inner, 6 outer)
        function getMetatronVertices(radius, rotation) {
            const vertices = [];

            // Center
            vertices.push({ x: 0, y: 0, ring: 0 });

            // Inner hexagon (6 vertices)
            for (let i = 0; i < 6; i++) {
                const angle = rotation + (i / 6) * Math.PI * 2;
                vertices.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius,
                    ring: 1
                });
            }

            // Outer hexagon (6 vertices, rotated 30Â°)
            for (let i = 0; i < 6; i++) {
                const angle = rotation + Math.PI / 6 + (i / 6) * Math.PI * 2;
                vertices.push({
                    x: Math.cos(angle) * radius * 2,
                    y: Math.sin(angle) * radius * 2,
                    ring: 2
                });
            }

            return vertices;
        }

        // Draw Metatron's Cube
        function drawMetatronsCube(x, y, radius, rotation, alpha, colorOffset) {
            const vertices = getMetatronVertices(radius, rotation);

            ctx.save();
            ctx.translate(x, y);

            // Draw all connecting lines (the sacred geometry pattern)
            ctx.globalCompositeOperation = 'lighter';

            for (let i = 0; i < vertices.length; i++) {
                for (let j = i + 1; j < vertices.length; j++) {
                    const v1 = vertices[i];
                    const v2 = vertices[j];

                    const colorIdx = Math.floor((colorOffset + i * 0.3 + j * 0.2) % palette.length);
                    const color = palette[colorIdx];
                    const rgb = hexToRgb(color);

                    const lineAlpha = alpha * 0.4;
                    ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${lineAlpha})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(v1.x, v1.y);
                    ctx.lineTo(v2.x, v2.y);
                    ctx.stroke();
                }
            }

            // Draw circles at vertices
            vertices.forEach((v, i) => {
                const colorIdx = Math.floor((colorOffset + i * 0.5) % palette.length);
                const color = palette[colorIdx];
                const rgb = hexToRgb(color);

                const circleAlpha = alpha * (v.ring === 0 ? 0.9 : v.ring === 1 ? 0.7 : 0.5);
                const circleRadius = radius * (v.ring === 0 ? 0.3 : 0.2);

                // Glow
                ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${circleAlpha * 0.3})`;
                ctx.beginPath();
                ctx.arc(v.x, v.y, circleRadius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${circleAlpha})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(v.x, v.y, circleRadius, 0, Math.PI * 2);
                ctx.stroke();
            });

            ctx.restore();
        }

        class VortexLayer {
            constructor(index) {
                this.index = index;
                this.z = index * 0.2;
                this.rotationDir = index % 2 === 0 ? 1 : -1;
                this.colorOffset = index * 0.8;
            }

            update(dt) {
                this.z += dt * 0.06; // Very slow
                if (this.z > 2) {
                    this.z = 0;
                    this.colorOffset = Math.random() * palette.length;
                }
            }

            draw() {
                const scale = 1 / (1 + this.z * 1.5);
                const alpha = smoothstep(0, 0.4, this.z) * smoothstep(2, 1.3, this.z);

                if (alpha < 0.01) return;

                const radius = 80 * scale;
                const rotation = time * 0.08 * this.rotationDir + this.index * 0.5;

                const parallax = this.z * 0.4;
                const offsetX = mouse.centeredX * 80 * parallax;
                const offsetY = mouse.centeredY * 80 * parallax;

                drawMetatronsCube(cx + offsetX, cy + offsetY, radius, rotation, alpha, this.colorOffset);
            }
        }

        const layers = Array.from({ length: layerCount }, (_, i) => new VortexLayer(i));

        function render() {
            time += 1 / 60;
            mouse.update();

            // Background
            const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H) * 0.7);
            bgGrad.addColorStop(0, '#080012');
            bgGrad.addColorStop(1, '#000008');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            // Slow fade trail
            ctx.fillStyle = 'rgba(0, 0, 0, 0.06)';
            ctx.fillRect(0, 0, W, H);

            const dt = 1 / 60;

            layers.sort((a, b) => b.z - a.z);
            layers.forEach(l => { l.update(dt); l.draw(); });

            // Central sacred glow
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 120);
            glow.addColorStop(0, 'rgba(179, 124, 255, 0.12)');
            glow.addColorStop(0.5, 'rgba(0, 245, 255, 0.05)');
            glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = glow;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();

            // Vignette
            const vig = ctx.createRadialGradient(cx, cy, Math.min(W, H) * 0.35, cx, cy, Math.max(W, H) * 0.7);
            vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vig.addColorStop(1, 'rgba(0, 0, 0, 0.65)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);

            requestAnimationFrame(render);
        }

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(render);
    </script>
</body>

</html>