<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Volumetric Cathedral - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 10px #ff0;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="info">
        VOLUMETRIC LIGHTING DEMO<br>
        God Rays + Volumetric Fog<br>
        <br>
        Watch the light stream through...
    </div>

    <script type="module">
        import * as THREE from '../lib/Three.js';
        import { createVolumetricSpotlight, GodRaysPass, VolumetricFogPass } from '../lib/fx/three/jazer-volumetric.js';
        import { createGPUParticles } from '../lib/fx/three/jazer-gpu-particles.js';
        import '../lib/engine/jazer-navigation.js';
        import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';
        // --- JaZeR UI schema (injected) ---
        const __jazerEffectFile = location.pathname.split('/').pop() || '';
        const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
        const { ui, expose, ready } = attachEffectUI({
          title: document.title,
          schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
        });
        window.JAZER_UI = ui;
        window.JAZER_EXPOSE = expose;
        window.JAZER_UI_READY = ready;
        // ------------------------------------


        window.THREE = THREE;
        const canvas = document.getElementById('c');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a15);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 40);
        camera.lookAt(0, 10, 0);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
        scene.add(ambientLight);

        // Create volumetric spotlights
        const spotlights = [];

        // Main spotlight from above
        const mainSpot = createVolumetricSpotlight(
            THREE,
            new THREE.Vector3(0, 30, 0),
            new THREE.Vector3(0, 0, 0),
            new THREE.Color(0xffd700),
            {
                intensity: 2.0,
                angle: Math.PI / 6,
                distance: 50,
                penumbra: 0.3,
                castShadow: true
            }
        );
        mainSpot.addToScene(scene);
        spotlights.push(mainSpot);

        // Side spotlights
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const radius = 25;
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                20,
                Math.sin(angle) * radius
            );

            const spotlight = createVolumetricSpotlight(
                THREE,
                pos,
                new THREE.Vector3(0, 5, 0),
                new THREE.Color().setHSL(i / 4, 0.8, 0.6),
                {
                    intensity: 1.5,
                    angle: Math.PI / 8,
                    distance: 40,
                    penumbra: 0.5
                }
            );
            spotlight.addToScene(scene);
            spotlights.push(spotlight);
        }

        // Create "cathedral" structure with pillars
        const pillarGeometry = new THREE.CylinderGeometry(1, 1, 25, 16);
        const pillarMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a4a,
            roughness: 0.8,
            metalness: 0.2
        });

        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = 20;

            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.set(
                Math.cos(angle) * radius,
                12.5,
                Math.sin(angle) * radius
            );
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            scene.add(pillar);
        }

        // Floor
        const floorGeometry = new THREE.CircleGeometry(35, 64);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            roughness: 0.9,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Ceiling
        const ceilingGeometry = new THREE.CircleGeometry(30, 64);
        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: 0x0f0f1e,
            roughness: 1.0,
            side: THREE.DoubleSide
        });
        const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = 30;
        scene.add(ceiling);

        // Central altar/pedestal
        const altarGeometry = new THREE.CylinderGeometry(3, 4, 4, 8);
        const altarMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a4a6a,
            roughness: 0.6,
            metalness: 0.4,
            emissive: 0x2a2a4a,
            emissiveIntensity: 0.2
        });
        const altar = new THREE.Mesh(altarGeometry, altarMaterial);
        altar.position.y = 2;
        altar.castShadow = true;
        altar.receiveShadow = true;
        scene.add(altar);

        // Floating particles for atmosphere
        const particleSystem = createGPUParticles(THREE, renderer, 'nebula', 50000);
        particleSystem.particleSize = 1.0;
        particleSystem.setBounds(-30, 0, -30, 30, 30, 30, true);
        particleSystem.setCurlNoise(0.2, 1.0);
        particleSystem.setGravity(0, -0.5, 0);
        particleSystem.damping = 0.1;
        scene.add(particleSystem.particles);

        // Post-processing setup
        const renderTarget = new THREE.WebGLRenderTarget(
            window.innerWidth,
            window.innerHeight,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            }
        );

        // God rays pass
        const godRaysPass = new GodRaysPass(THREE, {
            exposure: 0.4,
            decay: 0.96,
            density: 0.6,
            weight: 0.5,
            samples: 60
        });

        // Volumetric fog pass
        const fogPass = new VolumetricFogPass(THREE, {
            fogColor: new THREE.Vector3(0.05, 0.05, 0.15),
            fogNear: 10,
            fogFar: 80,
            fogDensity: 0.6,
            animated: true
        });

        // Fullscreen quad for post-processing
        class FullScreenQuad {
            constructor(material) {
                this._mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
            }

            get material() {
                return this._mesh.material;
            }

            set material(value) {
                this._mesh.material = value;
            }

            render(renderer) {
                const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                renderer.render(this._mesh, camera);
            }

            dispose() {
                this._mesh.geometry.dispose();
            }
        }

        const fsQuad = new FullScreenQuad(null);

        // Animation
        let time = 0;
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;

            time += deltaTime;

            // Animate main spotlight
            mainSpot.light.intensity = 2.0 + Math.sin(time * 0.5) * 0.5;

            // Animate side spotlights
            spotlights.slice(1).forEach((spot, i) => {
                const angle = (i / 4) * Math.PI * 2 + time * 0.2;
                const radius = 25;
                spot.setPosition(
                    Math.cos(angle) * radius,
                    20 + Math.sin(time * 0.3 + i) * 2,
                    Math.sin(angle) * radius
                );
                spot.update(deltaTime);
            });

            // Update particles
            particleSystem.update(deltaTime);

            // Animate camera
            const camRadius = 40;
            const camHeight = 15;
            camera.position.x = Math.cos(time * 0.1) * camRadius;
            camera.position.z = Math.sin(time * 0.1) * camRadius;
            camera.position.y = camHeight + Math.sin(time * 0.3) * 5;
            camera.lookAt(0, 10, 0);

            // Render scene to texture
            renderer.setRenderTarget(renderTarget);
            renderer.clear();
            renderer.render(scene, camera);

            // Apply god rays
            const godRaysTarget = renderTarget.clone();
            godRaysPass.updateLightPosition(camera, mainSpot.position);
            godRaysPass.render(renderer, godRaysTarget, renderTarget, deltaTime, false, fsQuad);

            // Apply volumetric fog (render to screen)
            fogPass.renderToScreen = true;
            fogPass.render(renderer, null, godRaysTarget, deltaTime, false, fsQuad, camera);

            godRaysTarget.dispose();
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderTarget.setSize(window.innerWidth, window.innerHeight);
            godRaysPass.setSize(window.innerWidth, window.innerHeight);
            fogPass.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
