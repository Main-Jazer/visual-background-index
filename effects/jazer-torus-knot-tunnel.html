<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Torus Knot Tunnel - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';

        // --- JaZeR UI schema (injected) ---
        const __jazerEffectFile = location.pathname.split('/').pop() || '';
        const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
        const { ui, expose, ready } = attachEffectUI({
          title: document.title,
          schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
        });
        window.JAZER_UI = ui;
        window.JAZER_EXPOSE = expose;
        window.JAZER_UI_READY = ready;
        // ------------------------------------

        /**
         * ============================================================================
         * TORUS KNOT TUNNEL - HIGH-END VISUAL ART
         * ============================================================================
         * CHANGELOG v2.0 - Artistic Upgrade
         * - Constrained palette: Deep space black + single accent color (cyan-magenta gradient)
         * - Removed heavy UI settings panel and all overlays
         * - Slow forward drift - form readable before motion
         * - One knot at a time as focal point, tunnel as context
         * - Forward motion only - stable cinematic camera
         * - Strong depth fog for tunnel focus
         * - Reduced knot count for clean composition
         * 
         * THESIS: "Infinite traversal through structured space"
         * ============================================================================
         */

        import * as THREE from '../lib/Three.js';
        import { mouse, smoothstep } from '../lib/engine/jazer-background-engine.js';
        import '../lib/engine/jazer-navigation.js';

        window.THREE = THREE;
        const canvas = document.getElementById('c');

        // === COLOR PALETTE (Restrained - Single Gradient) ===
        const COLORS = {
            deepSpace: new THREE.Color(0x020208),
            primary: new THREE.Color(0x00ccff),    // Cyan
            secondary: new THREE.Color(0x6622aa),  // Deep violet
            accent: new THREE.Color(0x9944ff),     // Purple accent
            subtle: new THREE.Color(0x222244)      // Muted structure
        };

        // Get color from gradient based on position
        function getGradientColor(t) {
            // Slow gradient from cyan to violet
            return COLORS.primary.clone().lerp(COLORS.secondary, t);
        }

        // === SCENE SETUP ===
        const scene = new THREE.Scene();
        scene.background = COLORS.deepSpace;
        scene.fog = new THREE.FogExp2(0x020208, 0.02); // Strong depth fog

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.85;

        // === TUNNEL PARAMETERS ===
        const tunnelRadius = 10;
        const tunnelLength = 300;

        // === TUNNEL RINGS (Subtle Structure) ===
        const ringCount = 20;
        const tunnelRings = [];

        for (let i = 0; i < ringCount; i++) {
            const ringGeometry = new THREE.RingGeometry(tunnelRadius - 0.15, tunnelRadius, 24);
            const t = i / ringCount;

            const ringMaterial = new THREE.MeshBasicMaterial({
                color: COLORS.subtle,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.15,
                wireframe: true
            });

            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.z = -i * (tunnelLength / ringCount);
            ring.userData = {
                baseZ: -i * (tunnelLength / ringCount)
            };

            scene.add(ring);
            tunnelRings.push(ring);
        }

        // === ENERGY CONDUITS (Minimal) ===
        const conduitCount = 6;
        const conduits = [];

        for (let i = 0; i < conduitCount; i++) {
            const angle = (i / conduitCount) * Math.PI * 2;
            const points = [];

            for (let j = 0; j < 80; j++) {
                const z = -j * 4;
                const x = Math.cos(angle) * (tunnelRadius * 0.9);
                const y = Math.sin(angle) * (tunnelRadius * 0.9);
                points.push(new THREE.Vector3(x, y, z));
            }

            const conduitGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const t = i / conduitCount;
            const color = getGradientColor(t);

            const conduitMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.25
            });

            const conduit = new THREE.Line(conduitGeometry, conduitMaterial);
            scene.add(conduit);
            conduits.push(conduit);
        }

        // === TORUS KNOTS (Reduced count, single variation focus) ===
        const knotCount = 8; // Reduced from 15
        const knots = [];
        const spacing = 30; // More space between knots

        for (let i = 0; i < knotCount; i++) {
            // Single knot variation for consistency
            const geometry = new THREE.TorusKnotGeometry(2.5, 0.4, 80, 12, 2, 3);
            const t = i / knotCount;
            const color = getGradientColor(t);

            const material = new THREE.MeshBasicMaterial({
                color: color,
                wireframe: true,
                transparent: true,
                opacity: 0.9
            });

            const knot = new THREE.Mesh(geometry, material);
            knot.position.z = -i * spacing - 30;

            knot.userData = {
                baseZ: -i * spacing - 30,
                rotationSpeed: 0.08 + (i % 3) * 0.02, // Slower rotation
                colorT: t
            };

            scene.add(knot);
            knots.push(knot);
        }

        // === MINIMAL PARTICLES (Dust motes) ===
        const particleCount = 800; // Reduced
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (tunnelRadius - 2) + 1;
            positions[i * 3] = Math.cos(angle) * radius;
            positions[i * 3 + 1] = Math.sin(angle) * radius;
            positions[i * 3 + 2] = -Math.random() * tunnelLength;

            // Subtle, desaturated colors
            const t = Math.random();
            const color = getGradientColor(t);
            colors[i * 3] = color.r * 0.5;
            colors[i * 3 + 1] = color.g * 0.5;
            colors[i * 3 + 2] = color.b * 0.5;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.08,
            vertexColors: true,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // === SUBTLE LIGHTING ===
        const ambientLight = new THREE.AmbientLight(0x111122, 0.3);
        scene.add(ambientLight);

        // === ANIMATION STATE ===
        let time = 0;
        let lastFrameTime = performance.now();
        const tunnelSpeed = 2.5; // Slower base speed
        const maxZ = spacing * knotCount + 30;

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            time += deltaTime;
            mouse.update();

            // Move tunnel rings forward
            tunnelRings.forEach(ring => {
                ring.position.z += tunnelSpeed * deltaTime;

                if (ring.position.z > 15) {
                    ring.position.z -= tunnelLength;
                }
            });

            // Update knots - slow, readable motion
            knots.forEach((knot, i) => {
                knot.position.z += tunnelSpeed * deltaTime;

                if (knot.position.z > 15) {
                    knot.position.z -= maxZ;
                    // Subtle color evolution
                    knot.userData.colorT = (knot.userData.colorT + 0.1) % 1;
                    knot.material.color = getGradientColor(knot.userData.colorT);
                }

                // Very slow rotation - form first
                knot.rotation.x = time * knot.userData.rotationSpeed * 0.5;
                knot.rotation.y = time * knot.userData.rotationSpeed * 0.3;

                // Distance-based opacity - focal point effect
                const dist = Math.abs(knot.position.z - camera.position.z);
                const opacity = smoothstep(80, 15, dist) * smoothstep(0, 8, dist);
                knot.material.opacity = opacity * 0.9;

                // Subtle breathing
                const breath = Math.sin(time * 0.3 + i) * 0.05 + 1;
                knot.scale.setScalar(breath);
            });

            // Update particles - slow drift
            const pos = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                pos[i * 3 + 2] += tunnelSpeed * deltaTime * 0.8;

                if (pos[i * 3 + 2] > 15) {
                    pos[i * 3 + 2] -= tunnelLength;
                    const newAngle = Math.random() * Math.PI * 2;
                    const newRadius = Math.random() * (tunnelRadius - 2) + 1;
                    pos[i * 3] = Math.cos(newAngle) * newRadius;
                    pos[i * 3 + 1] = Math.sin(newAngle) * newRadius;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // === CAMERA: Stable forward motion with minimal drift ===
            // Very subtle movement - let the tunnel be the motion
            camera.position.x = Math.sin(time * 0.1) * 0.5 + mouse.centeredX * 1.5;
            camera.position.y = Math.cos(time * 0.08) * 0.3 + mouse.centeredY * 1;
            camera.rotation.z = Math.sin(time * 0.05) * 0.02; // Minimal roll

            // Look ahead into the tunnel
            camera.lookAt(camera.position.x * 0.2, camera.position.y * 0.2, -50);

            renderer.render(scene, camera);
        }

        // === RESIZE HANDLER ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // === START ANIMATION ===
        animate();
    </script>
</body>

</html>