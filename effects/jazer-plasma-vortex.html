<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plasma Vortex - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import { noise3D, mouse, ColorPalettes } from '../lib/jazer-background-engine.js';

        import * as THREE from '../lib/Three.js';
        window.THREE = THREE;
        const canvas = document.getElementById('c');

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);

        // Plasma vortex parameters
        const ringCount = 15;
        const pointsPerRing = 120;
        const totalPoints = ringCount * pointsPerRing;

        // Geometry for plasma rings
        const plasmaGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(totalPoints * 3);
        const colors = new Float32Array(totalPoints * 3);
        const sizes = new Float32Array(totalPoints);

        // Create spiral plasma rings
        let idx = 0;
        for (let ring = 0; ring < ringCount; ring++) {
            const radius = 2 + ring * 0.5;
            const ringHeight = (ring - ringCount/2) * 0.8;
            
            for (let i = 0; i < pointsPerRing; i++) {
                const i3 = idx * 3;
                const angle = (i / pointsPerRing) * Math.PI * 2;
                
                // Spiral pattern with vertical offset
                const x = Math.cos(angle + ring * 0.2) * radius;
                const y = Math.sin(angle + ring * 0.2) * radius;
                const z = ringHeight + Math.sin(angle * 3) * 0.2;
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                // Dynamic color based on position and time
                const hue = (angle / (Math.PI * 2) + ring * 0.1) % 1;
                const saturation = 0.8 + Math.sin(angle * 4) * 0.2;
                const lightness = 0.5 + Math.sin(angle * 6 + ring * 0.5) * 0.2;
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                sizes[idx] = 0.05 + Math.sin(angle * 5) * 0.03;
                
                idx++;
            }
        }

        plasmaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        plasmaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        plasmaGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Custom shader for plasma particles
        const plasmaMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                mouse: { value: new THREE.Vector2(0, 0) }
            },
            vertexShader: `
                uniform float time;
                uniform vec2 mouse;
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                varying float vTime;

                void main() {
                    vColor = color;
                    vTime = time;
                    
                    vec3 pos = position;
                    
                    // Rotational movement
                    float distFromCenter = length(pos.xy);
                    float rotationSpeed = 0.5 / (distFromCenter + 1.0);
                    float angle = atan(pos.y, pos.x) + time * rotationSpeed;
                    
                    // Spiral inward motion
                    float spiralFactor = 0.01 * time;
                    float newRadius = max(0.5, distFromCenter - spiralFactor);
                    pos.x = cos(angle) * newRadius;
                    pos.y = sin(angle) * newRadius;
                    
                    // Pulsating effect
                    float pulse = sin(time * 2.0 + distFromCenter * 2.0) * 0.1;
                    pos.xy *= 1.0 + pulse;
                    
                    // Mouse repulsion
                    vec3 mouseVec = vec3(mouse.x * 5.0, -mouse.y * 5.0, pos.z);
                    float mouseDist = distance(pos, mouseVec);
                    if (mouseDist < 2.0) {
                        vec3 repelDir = normalize(pos - mouseVec);
                        pos += repelDir * (2.0 - mouseDist) * 0.5;
                    }
                    
                    // Noise-based perturbation
                    pos.x += sin(time * 0.8 + pos.y * 2.0 + pos.z * 1.5) * 0.05;
                    pos.y += cos(time * 0.7 + pos.x * 1.5 + pos.z * 2.0) * 0.05;
                    pos.z += sin(time * 0.9 + pos.x * 1.0 + pos.y * 1.8) * 0.05;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * 200.0 * (30.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vTime;

                void main() {
                    float dist = length(gl_PointCoord - 0.5);
                    if (dist > 0.5) discard;
                    
                    float alpha = 1.0 - dist * 2.0;
                    alpha = pow(alpha, 1.5);
                    
                    // Add glow effect
                    float glow = 1.0 + sin(vTime * 5.0) * 0.3;
                    
                    gl_FragColor = vec4(vColor * glow, alpha * glow);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const plasmaVortex = new THREE.Points(plasmaGeometry, plasmaMaterial);
        scene.add(plasmaVortex);

        // Central plasma core
        const coreGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const coreMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                uniform float time;
                varying vec3 vNormal;
                
                void main() {
                    vNormal = normal;
                    
                    // Distort the sphere surface with noise
                    vec3 pos = position;
                    float noise = noise3D(pos.x, pos.y, pos.z + time * 2.0);
                    pos = normalize(pos) * (0.8 + noise * 0.1);
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vNormal;
                
                void main() {
                    // Create a dynamic plasma-like color pattern
                    float n1 = noise3D(vNormal.x * 5.0, vNormal.y * 5.0, time * 2.0);
                    float n2 = noise3D(vNormal.y * 5.0, vNormal.z * 5.0, time * 2.5 + 100.0);
                    float n3 = noise3D(vNormal.z * 5.0, vNormal.x * 5.0, time * 3.0 + 200.0);
                    
                    float hue = (sin(time + n1 * 2.0) * 0.2 + 0.4) % 1.0;
                    float sat = 0.8 + n2 * 0.2;
                    float val = 0.6 + n3 * 0.3;
                    
                    // Convert HSV to RGB
                    vec3 hsv = vec3(hue, sat, val);
                    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                    vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);
                    vec3 color = hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);
                    
                    float intensity = 1.0 - length(vNormal) * 0.2;
                    gl_FragColor = vec4(color * intensity, 0.9);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        
        const plasmaCore = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(plasmaCore);

        // Outer plasma ring
        const outerRingGeometry = new THREE.TorusGeometry(5, 0.1, 16, 100);
        const outerRingMaterial = new THREE.MeshBasicMaterial({
            color: 0xff5500,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide
        });
        const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
        scene.add(outerRing);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x222255, 0.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
        pointLight2.position.set(-5, -5, -5);
        scene.add(pointLight2);

        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            mouse.update();

            // Update uniforms
            plasmaMaterial.uniforms.time.value = time;
            plasmaMaterial.uniforms.mouse.value.set(mouse.centeredX, mouse.centeredY);
            coreMaterial.uniforms.time.value = time;

            // Rotate the vortex
            plasmaVortex.rotation.x = time * 0.02;
            plasmaVortex.rotation.y = time * 0.05;
            outerRing.rotation.x = time * 0.01;
            outerRing.rotation.y = time * 0.03;

            // Core rotation and pulsation
            plasmaCore.rotation.y = time * 0.5;
            const pulse = 1.0 + Math.sin(time * 4) * 0.1;
            plasmaCore.scale.setScalar(pulse);

            // Camera movement with mouse
            camera.position.x = Math.sin(time * 0.05) * 3 + mouse.centeredX * 1.5;
            camera.position.y = Math.cos(time * 0.07) * 2 + mouse.centeredY * 1.5;
            camera.position.z = 10 + Math.sin(time * 0.03) * 1;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>