<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Crystal Lattice Network - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script type="module">
        import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';

        // --- JaZeR UI schema (injected) ---
        const __jazerEffectFile = location.pathname.split('/').pop() || '';
        const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
        const { ui, expose, ready } = attachEffectUI({
          title: document.title,
          schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
        });
        window.JAZER_UI = ui;
        window.JAZER_EXPOSE = expose;
        window.JAZER_UI_READY = ready;
        // ------------------------------------

        /**
         * ============================================================================
         * CRYSTAL LATTICE NETWORK - HIGH-END VISUAL ART
         * ============================================================================
         * CHANGELOG v2.0 - Artistic Upgrade
         * - Constrained palette: Midnight blue base + cyan energy + rare gold accents
         * - Removed rainbow HSL color cycling
         * - Added 8-10 second breathing cycles with moments of near-stillness
         * - Established visual hierarchy: Center crystal (primary), lattice (structure)
         * - Removed busy floating shards to reduce visual competition
         * - Camera: Slow asymmetric drift with subtle parallax
         * - Finish: Light grain, restrained vignette, cooler temperature
         * 
         * THESIS: "Frozen geometry awakening with internal energy"
         * ============================================================================
         */

        import { noise3D, mouse } from '../lib/engine/jazer-background-engine.js';
        import '../lib/engine/jazer-navigation.js';
        import * as THREE from '../lib/Three.js';
        window.THREE = THREE;
        const canvas = document.getElementById('c');

        // === COLOR PALETTE (Restrained) ===
        const COLORS = {
            base: new THREE.Color(0x0a0a1a),       // Deep midnight
            structure: new THREE.Color(0x1a2a4a), // Muted blue-grey
            energy: new THREE.Color(0x00a8cc),    // Primary cyan
            accent: new THREE.Color(0x4a9eff),    // Secondary blue
            highlight: new THREE.Color(0xffd700), // Rare gold glint
            glow: new THREE.Color(0x0066aa)       // Subtle glow
        };

        // === SCENE SETUP ===
        const scene = new THREE.Scene();
        scene.background = COLORS.base;
        scene.fog = new THREE.FogExp2(0x0a0a1a, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 15);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9;

        // === LATTICE PARAMETERS ===
        const gridSize = 6;
        const spacing = 2.2;
        const nodeCount = gridSize * gridSize * gridSize;

        // === CREATE NODES ===
        const nodes = [];
        const nodePositions = [];

        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                for (let z = 0; z < gridSize; z++) {
                    const pos = new THREE.Vector3(
                        (x - gridSize / 2) * spacing,
                        (y - gridSize / 2) * spacing,
                        (z - gridSize / 2) * spacing
                    );

                    nodePositions.push(pos.clone());

                    // Distance from center for energy distribution
                    const distFromCenter = pos.length();
                    const energyFactor = Math.max(0, 1 - distFromCenter / (gridSize * spacing * 0.6));

                    nodes.push({
                        position: pos,
                        originalPosition: pos.clone(),
                        phase: Math.random() * Math.PI * 2,
                        energyFactor: energyFactor,
                        // Long breathing cycle - 8-12 seconds
                        breathCycle: 8 + Math.random() * 4
                    });
                }
            }
        }

        // === NODE GEOMETRY ===
        const nodeGeometry = new THREE.BufferGeometry();
        const nodePositionsArray = new Float32Array(nodeCount * 3);
        const nodeColors = new Float32Array(nodeCount * 3);
        const nodeSizes = new Float32Array(nodeCount);

        for (let i = 0; i < nodeCount; i++) {
            const i3 = i * 3;
            const node = nodes[i];

            nodePositionsArray[i3] = node.position.x;
            nodePositionsArray[i3 + 1] = node.position.y;
            nodePositionsArray[i3 + 2] = node.position.z;

            // Color based on energy factor (closer to center = more energy)
            const color = COLORS.structure.clone().lerp(COLORS.energy, node.energyFactor * 0.6);
            nodeColors[i3] = color.r;
            nodeColors[i3 + 1] = color.g;
            nodeColors[i3 + 2] = color.b;

            nodeSizes[i] = 0.15 + node.energyFactor * 0.1;
        }

        nodeGeometry.setAttribute('position', new THREE.BufferAttribute(nodePositionsArray, 3));
        nodeGeometry.setAttribute('color', new THREE.BufferAttribute(nodeColors, 3));
        nodeGeometry.setAttribute('size', new THREE.BufferAttribute(nodeSizes, 1));

        // === NODE MATERIAL (Refined) ===
        const nodeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                breathPhase: { value: 0 }
            },
            vertexShader: `
                uniform float time;
                uniform float breathPhase;
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                varying float vIntensity;

                void main() {
                    vColor = color;
                    
                    vec3 pos = position;
                    
                    // Gentle breathing movement - slower, more intentional
                    float breath = sin(breathPhase) * 0.5 + 0.5;
                    float localBreath = sin(time * 0.1 + pos.x * 0.2 + pos.y * 0.2 + pos.z * 0.2);
                    
                    pos += normalize(pos) * localBreath * 0.05 * breath;
                    
                    vIntensity = 0.6 + breath * 0.4;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * 80.0 * (25.0 / -mvPosition.z) * (0.8 + breath * 0.2);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vIntensity;

                void main() {
                    float dist = length(gl_PointCoord - 0.5);
                    if (dist > 0.5) discard;
                    
                    float alpha = 1.0 - dist * 2.0;
                    alpha = pow(alpha, 1.5);
                    
                    gl_FragColor = vec4(vColor * vIntensity, alpha * 0.8);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const nodeSystem = new THREE.Points(nodeGeometry, nodeMaterial);
        scene.add(nodeSystem);

        // === CONNECTIONS (Refined - fewer, intentional) ===
        const connectionDistance = 2.5;
        const connectionGroup = new THREE.Group();

        for (let i = 0; i < nodeCount; i++) {
            for (let j = i + 1; j < nodeCount; j++) {
                const dist = nodes[i].position.distanceTo(nodes[j].position);

                if (dist < connectionDistance) {
                    const avgEnergy = (nodes[i].energyFactor + nodes[j].energyFactor) / 2;

                    // Only show connections with sufficient energy
                    if (avgEnergy < 0.2) continue;

                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        nodes[i].position.x, nodes[i].position.y, nodes[i].position.z,
                        nodes[j].position.x, nodes[j].position.y, nodes[j].position.z
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                    const color = COLORS.structure.clone().lerp(COLORS.energy, avgEnergy * 0.5);
                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.15 + avgEnergy * 0.2,
                        blending: THREE.AdditiveBlending
                    });

                    const line = new THREE.Line(geometry, material);
                    line.userData = { avgEnergy };
                    connectionGroup.add(line);
                }
            }
        }
        scene.add(connectionGroup);

        // === CENTER CRYSTAL (Primary Focus) ===
        const centerGeometry = new THREE.OctahedronGeometry(1.2, 1);
        const centerMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                breathPhase: { value: 0 },
                baseColor: { value: COLORS.energy },
                accentColor: { value: COLORS.accent }
            },
            vertexShader: `
                uniform float time;
                uniform float breathPhase;
                varying vec3 vNormal;
                varying vec3 vPosition;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    
                    // Subtle morph synchronized with breath
                    float breath = sin(breathPhase) * 0.5 + 0.5;
                    vec3 pos = position;
                    pos += normal * breath * 0.08;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float breathPhase;
                uniform vec3 baseColor;
                uniform vec3 accentColor;
                varying vec3 vNormal;
                varying vec3 vPosition;
                
                void main() {
                    float breath = sin(breathPhase) * 0.5 + 0.5;
                    
                    // Fresnel edge glow
                    float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                    
                    // Slow color shift between base and accent
                    float colorT = sin(time * 0.05) * 0.5 + 0.5;
                    vec3 color = mix(baseColor, accentColor, colorT * 0.3);
                    
                    // Intensity follows breath
                    float intensity = 0.4 + breath * 0.6;
                    
                    vec3 finalColor = color * intensity * (1.0 + fresnel * 0.5);
                    gl_FragColor = vec4(finalColor, 0.7 + fresnel * 0.3);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });

        const crystalCenter = new THREE.Mesh(centerGeometry, centerMaterial);
        scene.add(crystalCenter);

        // === INNER GLOW ===
        const glowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: COLORS.glow,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        });
        const innerGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(innerGlow);

        // === SUBTLE LIGHTING ===
        const ambientLight = new THREE.AmbientLight(0x101020, 0.4);
        scene.add(ambientLight);

        const keyLight = new THREE.PointLight(COLORS.energy.getHex(), 0.8, 50);
        keyLight.position.set(5, 8, 10);
        scene.add(keyLight);

        const fillLight = new THREE.PointLight(COLORS.accent.getHex(), 0.3, 40);
        fillLight.position.set(-8, -5, 5);
        scene.add(fillLight);

        // === ANIMATION STATE ===
        let time = 0;
        let breathPhase = 0;
        const BREATH_PERIOD = 10; // 10 second breath cycle

        function animate() {
            requestAnimationFrame(animate);

            const dt = 0.016;
            time += dt;

            // Master breath phase - long, slow cycle
            breathPhase = (time / BREATH_PERIOD) * Math.PI * 2;
            const breath = Math.sin(breathPhase) * 0.5 + 0.5;

            mouse.update();

            // Update node shader uniforms
            nodeMaterial.uniforms.time.value = time;
            nodeMaterial.uniforms.breathPhase.value = breathPhase;

            // Update center crystal
            // Very slow rotation - form first, motion second
            crystalCenter.rotation.y = time * 0.03;
            crystalCenter.rotation.x = Math.sin(time * 0.02) * 0.1;
            centerMaterial.uniforms.time.value = time;
            centerMaterial.uniforms.breathPhase.value = breathPhase;

            // Inner glow pulses with breath
            innerGlow.scale.setScalar(0.8 + breath * 0.3);
            glowMaterial.opacity = 0.2 + breath * 0.2;

            // Update connection opacities with breath
            connectionGroup.children.forEach(line => {
                const baseOpacity = 0.1 + line.userData.avgEnergy * 0.15;
                line.material.opacity = baseOpacity * (0.6 + breath * 0.4);
            });

            // === CAMERA: Slow asymmetric drift ===
            const camTime = time * 0.03;
            camera.position.x = 8 + Math.sin(camTime) * 4 + mouse.centeredX * 2;
            camera.position.y = 6 + Math.cos(camTime * 0.7) * 3 + mouse.centeredY * 1.5;
            camera.position.z = 15 + Math.sin(camTime * 0.5) * 2;

            // Look slightly off-center for asymmetry
            camera.lookAt(0.5, 0.3, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>