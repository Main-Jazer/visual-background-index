<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Crystal Lattice Network - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script src="../Three.js"></script>
    <script type="module">
        import { noise3D, mouse, ColorPalettes } from '../jazer-background-engine.js';

        const THREE = window.THREE;
        const canvas = document.getElementById('c');

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);

        // Crystal lattice parameters
        const gridSize = 8;
        const spacing = 2;
        const nodeCount = gridSize * gridSize * gridSize;
        const connectionDistance = 3;

        // Create crystal nodes
        const nodes = [];
        const nodePositions = [];

        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                for (let z = 0; z < gridSize; z++) {
                    const pos = new THREE.Vector3(
                        (x - gridSize/2) * spacing + (Math.random() - 0.5) * 0.5,
                        (y - gridSize/2) * spacing + (Math.random() - 0.5) * 0.5,
                        (z - gridSize/2) * spacing + (Math.random() - 0.5) * 0.5
                    );
                    
                    nodePositions.push(pos.clone());
                    
                    // Store original position for oscillation
                    nodes.push({
                        position: pos,
                        originalPosition: pos.clone(),
                        phase: Math.random() * Math.PI * 2,
                        frequency: 0.5 + Math.random() * 0.5,
                        amplitude: 0.1 + Math.random() * 0.1
                    });
                }
            }
        }

        // Create geometry for nodes
        const nodeGeometry = new THREE.BufferGeometry();
        const nodePositionsArray = new Float32Array(nodeCount * 3);
        const nodeColors = new Float32Array(nodeCount * 3);
        const nodeSizes = new Float32Array(nodeCount);

        for (let i = 0; i < nodeCount; i++) {
            const i3 = i * 3;
            const node = nodes[i];
            
            nodePositionsArray[i3] = node.position.x;
            nodePositionsArray[i3 + 1] = node.position.y;
            nodePositionsArray[i3 + 2] = node.position.z;
            
            // Assign colors based on position
            const hue = (node.position.x + node.position.y + node.position.z) * 0.1 % 1;
            const color = new THREE.Color().setHSL(hue, 0.9, 0.7);
            nodeColors[i3] = color.r;
            nodeColors[i3 + 1] = color.g;
            nodeColors[i3 + 2] = color.b;
            
            nodeSizes[i] = 0.2 + Math.random() * 0.1;
        }

        nodeGeometry.setAttribute('position', new THREE.BufferAttribute(nodePositionsArray, 3));
        nodeGeometry.setAttribute('color', new THREE.BufferAttribute(nodeColors, 3));
        nodeGeometry.setAttribute('size', new THREE.BufferAttribute(nodeSizes, 1));

        // Node material
        const nodeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                mouse: { value: new THREE.Vector2(0, 0) }
            },
            vertexShader: `
                uniform float time;
                uniform vec2 mouse;
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                varying float vPulse;

                void main() {
                    vColor = color;
                    
                    vec3 pos = position;
                    
                    // Oscillate nodes
                    float pulse = sin(time * 2.0 + pos.x + pos.y + pos.z) * 0.1;
                    vPulse = pulse * 5.0 + 0.5;
                    
                    // Add subtle movement
                    pos.x += sin(time * 0.8 + pos.y * 0.5 + pos.z * 0.7) * 0.1;
                    pos.y += cos(time * 0.9 + pos.x * 0.6 + pos.z * 0.8) * 0.1;
                    pos.z += sin(time * 1.0 + pos.x * 0.7 + pos.y * 0.9) * 0.1;
                    
                    // Mouse interaction
                    vec3 mouseVec = vec3(mouse.x * 10.0, -mouse.y * 10.0, 0.0);
                    float mouseDist = distance(pos, mouseVec);
                    if (mouseDist < 5.0) {
                        pos += normalize(pos - mouseVec) * (5.0 - mouseDist) * 0.2;
                    }
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * 100.0 * (30.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vPulse;

                void main() {
                    float dist = length(gl_PointCoord - 0.5);
                    if (dist > 0.5) discard;
                    
                    float alpha = 1.0 - dist * 2.0;
                    alpha = pow(alpha, 1.0);
                    
                    // Add pulsing effect
                    float pulse = vPulse;
                    
                    gl_FragColor = vec4(vColor * pulse, alpha * pulse);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const nodeSystem = new THREE.Points(nodeGeometry, nodeMaterial);
        scene.add(nodeSystem);

        // Create connections between nearby nodes
        const connectionLines = [];
        const lineGeometries = [];
        const lineMaterials = [];

        for (let i = 0; i < nodeCount; i++) {
            for (let j = i + 1; j < nodeCount; j++) {
                const dist = nodes[i].position.distanceTo(nodes[j].position);
                
                if (dist < connectionDistance) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        nodes[i].position.x, nodes[i].position.y, nodes[i].position.z,
                        nodes[j].position.x, nodes[j].position.y, nodes[j].position.z
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    // Connection material
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            color1: { value: new THREE.Color(nodes[i].position.x * 0.1, 0.5, 0.7) },
                            color2: { value: new THREE.Color(nodes[j].position.y * 0.1, 0.5, 0.7) },
                            dist: { value: dist }
                        },
                        vertexShader: `
                            void main() {
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 color1;
                            uniform vec3 color2;
                            uniform float dist;
                            
                            void main() {
                                float t = (sin(time * 2.0) + 1.0) / 2.0;
                                vec3 color = mix(color1, color2, t);
                                
                                // Fade out based on distance
                                float alpha = 1.0 - (dist / 3.0);
                                gl_FragColor = vec4(color, alpha * 0.3);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    
                    connectionLines.push(line);
                    lineGeometries.push(geometry);
                    lineMaterials.push(material);
                }
            }
        }

        // Crystal center piece
        const centerGeometry = new THREE.OctahedronGeometry(1.5, 2);
        const centerMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                uniform float time;
                varying vec3 vNormal;
                
                void main() {
                    vNormal = normal;
                    
                    // Morph the shape slightly
                    vec3 pos = position;
                    float noise = noise3D(pos.x * 2.0, pos.y * 2.0, pos.z * 2.0 + time * 3.0);
                    pos += normal * noise * 0.2;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vNormal;
                
                void main() {
                    // Create a faceted crystal appearance
                    float facetPattern = sin(vNormal.x * 10.0) * sin(vNormal.y * 10.0) * sin(vNormal.z * 10.0);
                    facetPattern = abs(facetPattern);
                    
                    // Color cycling
                    float hue = (sin(time * 0.5) * 0.5 + 0.5) % 1.0;
                    vec3 color = vec3(0.5);
                    
                    // Convert HSV to RGB
                    vec3 hsv = vec3(hue, 0.8, 0.9);
                    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                    vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);
                    color = hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);
                    
                    // Apply facet pattern
                    color *= (facetPattern * 0.5 + 0.5);
                    
                    float intensity = 1.0 - length(vNormal) * 0.1;
                    gl_FragColor = vec4(color * intensity, 0.8);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        
        const crystalCenter = new THREE.Mesh(centerGeometry, centerMaterial);
        scene.add(crystalCenter);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x222255, 0.3);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
        pointLight2.position.set(-5, -5, -5);
        scene.add(pointLight2);

        // Add some floating crystal shards
        const shardCount = 20;
        const shards = [];
        
        for (let i = 0; i < shardCount; i++) {
            const shardGeometry = new THREE.TetrahedronGeometry(0.2, 0);
            const shardMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6,
                wireframe: true
            });
            
            const shard = new THREE.Mesh(shardGeometry, shardMaterial);
            
            // Position randomly around the lattice
            shard.position.set(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20
            );
            
            shard.userData = {
                rotationSpeed: new THREE.Vector3(
                    Math.random() * 0.02,
                    Math.random() * 0.02,
                    Math.random() * 0.02
                ),
                orbitRadius: 5 + Math.random() * 10,
                orbitSpeed: 0.1 + Math.random() * 0.2,
                angle: Math.random() * Math.PI * 2
            };
            
            scene.add(shard);
            shards.push(shard);
        }

        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            mouse.update();

            // Update node positions
            const positions = nodeSystem.geometry.attributes.position.array;
            for (let i = 0; i < nodeCount; i++) {
                const i3 = i * 3;
                const node = nodes[i];
                
                // Calculate new position with oscillation
                const offsetX = Math.sin(time * node.frequency + node.phase) * node.amplitude;
                const offsetY = Math.cos(time * node.frequency * 1.2 + node.phase) * node.amplitude;
                const offsetZ = Math.sin(time * node.frequency * 0.8 + node.phase) * node.amplitude;
                
                positions[i3] = node.originalPosition.x + offsetX;
                positions[i3 + 1] = node.originalPosition.y + offsetY;
                positions[i3 + 2] = node.originalPosition.z + offsetZ;
            }
            nodeSystem.geometry.attributes.position.needsUpdate = true;

            // Update node material uniforms
            nodeMaterial.uniforms.time.value = time;
            nodeMaterial.uniforms.mouse.value.set(mouse.centeredX, mouse.centeredY);

            // Update connection materials
            for (let i = 0; i < lineMaterials.length; i++) {
                lineMaterials[i].uniforms.time.value = time;
            }

            // Update center crystal
            crystalCenter.rotation.x = time * 0.3;
            crystalCenter.rotation.y = time * 0.5;
            centerMaterial.uniforms.time.value = time;

            // Update floating shards
            for (let i = 0; i < shards.length; i++) {
                const shard = shards[i];
                const data = shard.userData;
                
                // Orbit around center
                data.angle += data.orbitSpeed * 0.01;
                shard.position.x = Math.cos(data.angle) * data.orbitRadius;
                shard.position.z = Math.sin(data.angle) * data.orbitRadius;
                shard.position.y += Math.sin(time * 0.5 + i) * 0.02;
                
                // Rotate the shard
                shard.rotation.x += data.rotationSpeed.x;
                shard.rotation.y += data.rotationSpeed.y;
                shard.rotation.z += data.rotationSpeed.z;
            }

            // Camera movement with mouse
            camera.position.x = Math.sin(time * 0.05) * 8 + mouse.centeredX * 3;
            camera.position.y = Math.cos(time * 0.07) * 5 + mouse.centeredY * 2;
            camera.position.z = 15 + Math.sin(time * 0.03) * 3;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>