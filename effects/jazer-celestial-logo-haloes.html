<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JaZeR Celestial Logo Haloes</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: radial-gradient(circle at 50% 0%, #06061b, #010108 70%);
      color: #f8fbff;
      overflow: hidden;
      min-height: 100vh;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .label {
      position: fixed;
      left: 2rem;
      bottom: 1.5rem;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.45);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="effect"></canvas>
  <div class="label">Celestial Logo Haloes</div>
  <script type="module">
    import { mouse, noise2D, ColorPalettes } from '../lib/jazer-background-engine.js';

    const canvas = document.getElementById('effect');
    const ctx = canvas.getContext('2d');
    const palette = ColorPalettes.galaxy || ColorPalettes.cyberpunk || ColorPalettes.jazer;

    const TEXT = 'JaZeR';
    const HALO_RINGS = 3;
    const PARTICLES_PER_RING = 60;
    const DUST_COUNT = 220;

    const letterInfo = [];
    const haloParticles = [];
    const dustParticles = [];

    let width = 0;
    let height = 0;
    let fontSize = 140;
    let lastTime = 0;
    let time = 0;

    class HaloParticle {
      constructor(letterIndex, ring) {
        this.letterIndex = letterIndex;
        this.ring = ring;
        this.reset(true);
      }

      reset(initial = false) {
        this.angle = Math.random() * Math.PI * 2;
        this.radius = fontSize * (0.25 + this.ring * 0.2) + Math.random() * 10;
        this.speed = (0.4 + this.ring * 0.15) * (Math.random() > 0.5 ? 1 : -1);
        this.size = 1 + Math.random() * 2;
        this.phase = Math.random() * Math.PI * 2;
        this.noiseOffset = Math.random() * 1000;
        this.alpha = 0.4 + Math.random() * 0.4;
        if (!initial) {
          this.angle = Math.random() * Math.PI * 2;
        }
      }

      update(dt) {
        this.angle += this.speed * dt;
      }

      draw() {
        const letter = letterInfo[this.letterIndex];
        if (!letter) return;
        const wobble = noise2D(this.angle, time * 0.6 + this.noiseOffset) * 8;
        const x = letter.x + Math.cos(this.angle) * (this.radius + wobble) + mouse.centeredX * this.ring * 6;
        const y = letter.y + Math.sin(this.angle) * (this.radius * 0.55 + wobble * 0.3) + mouse.centeredY * this.ring * 10;
        const pulse = Math.sin(time * 3 + this.phase) * 0.3 + 1;
        ctx.fillStyle = `${letter.color}${Math.floor(this.alpha * 255).toString(16).padStart(2, '0')}`;
        ctx.shadowColor = letter.color;
        ctx.shadowBlur = 18;
        ctx.beginPath();
        ctx.arc(x, y, this.size * pulse, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class DustParticle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.speed = 10 + Math.random() * 25;
        this.alpha = 0.05 + Math.random() * 0.15;
        this.color = palette[Math.floor(Math.random() * palette.length)] || '#ffffff';
      }

      update(dt) {
        this.y -= dt * this.speed;
        this.x += mouse.centeredX * dt * 40;
        if (this.y < -10) {
          this.y = height + 10;
          this.x = Math.random() * width;
        }
      }

      draw() {
        ctx.fillStyle = `${this.color}${Math.floor(this.alpha * 255).toString(16).padStart(2, '0')}`;
        ctx.fillRect(this.x, this.y, 2, 2);
      }
    }

    function setup() {
      for (let i = 0; i < DUST_COUNT; i++) {
        dustParticles.push(new DustParticle());
      }
      resize();
      rebuildLetters();
      rebuildHaloParticles();
      requestAnimationFrame(render);
    }

    function resize() {
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      fontSize = Math.max(90, Math.min(width * 0.12, 180));
      rebuildLetters();
      rebuildHaloParticles();
    }

    function rebuildLetters() {
      letterInfo.length = 0;
      ctx.font = `${fontSize}px 'Inter', sans-serif`;
      const spacing = fontSize * 0.12;
      const widths = [...TEXT].map(char => ctx.measureText(char).width);
      const totalWidth = widths.reduce((sum, w) => sum + w, 0) + spacing * (TEXT.length - 1);
      let cursor = width / 2 - totalWidth / 2;
      [...TEXT].forEach((char, index) => {
        const w = widths[index];
        letterInfo.push({
          char,
          x: cursor + w / 2,
          y: height / 2,
          width: w,
          color: palette[index % palette.length] || '#00f5ff'
        });
        cursor += w + spacing;
      });
    }

    function rebuildHaloParticles() {
      haloParticles.length = 0;
      letterInfo.forEach((letter, letterIndex) => {
        for (let ring = 0; ring < HALO_RINGS; ring++) {
          const count = PARTICLES_PER_RING + ring * 15;
          for (let i = 0; i < count; i++) {
            haloParticles.push(new HaloParticle(letterIndex, ring));
          }
        }
      });
    }

    window.addEventListener('resize', resize);

    function render(now) {
      const dt = (now - lastTime) / 1000 || 0;
      lastTime = now;
      time += dt;
      mouse.update();

      ctx.clearRect(0, 0, width, height);
      drawBackground();

      dustParticles.forEach(particle => {
        particle.update(dt);
        particle.draw();
      });

      drawLetterHalos();
      drawConnectors();

      haloParticles.forEach(particle => {
        particle.update(dt);
        particle.draw();
      });

      drawLetters();
      drawScanlines();

      requestAnimationFrame(render);
    }

    function drawBackground() {
      const gradient = ctx.createRadialGradient(width / 2, height * 0.4, 50, width / 2, height, Math.max(width, height));
      gradient.addColorStop(0, '#070819');
      gradient.addColorStop(1, '#000005');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }

    function drawLetterHalos() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      letterInfo.forEach(letter => {
        const glow = ctx.createRadialGradient(letter.x, letter.y, 0, letter.x, letter.y, fontSize * 0.9);
        glow.addColorStop(0, `${letter.color}33`);
        glow.addColorStop(1, '#00000000');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(letter.x, letter.y, fontSize * 0.9, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
    }

    function drawConnectors() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineWidth = 1.2;
      for (let i = 0; i < letterInfo.length - 1; i++) {
        const from = letterInfo[i];
        const to = letterInfo[i + 1];
        ctx.strokeStyle = `${from.color}55`;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y - fontSize * 0.15);
        ctx.quadraticCurveTo((from.x + to.x) / 2, from.y - fontSize * 0.6, to.x, to.y - fontSize * 0.15);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawLetters() {
      ctx.save();
      ctx.font = `${fontSize}px 'Inter', sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      letterInfo.forEach(letter => {
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = letter.color;
        ctx.shadowBlur = 35;
        ctx.fillText(letter.char, letter.x, letter.y);
        ctx.fillStyle = `${letter.color}dd`;
        ctx.shadowBlur = 10;
        ctx.fillText(letter.char, letter.x, letter.y);
      });
      ctx.restore();
    }

    function drawScanlines() {
      ctx.save();
      ctx.globalAlpha = 0.07;
      ctx.fillStyle = '#04040c';
      for (let y = 0; y < height; y += 3) {
        ctx.fillRect(0, y, width, 1);
      }
      ctx.restore();
    }

    setup();
  </script>
</body>
</html>
