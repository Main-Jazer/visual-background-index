<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Materials Showcase - JaZeR</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 100;
        }

        #materialName {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <div id="info">
        <div id="materialName">HOLOGRAPHIC</div>
        Advanced Materials Showcase<br>
        Click to cycle materials<br>
        <span id="materialIndex">1</span> / 8
    </div>

    <script type="module">
        import * as THREE from '../lib/Three.js';
        import {
        import { attachEffectUI } from '../lib/engine/jazer-effect-ui-schema.js';

        // --- JaZeR UI schema (injected) ---
        const __jazerEffectFile = location.pathname.split('/').pop() || '';
        const __jazerEffectName = __jazerEffectFile.replace(/\.html$/i, '');
        const { ui, expose, ready } = attachEffectUI({
          title: document.title,
          schemaUrl: new URL(`./ui-schema/${__jazerEffectName}.ui.json`, import.meta.url)
        });
        window.JAZER_UI = ui;
        window.JAZER_EXPOSE = expose;
        window.JAZER_UI_READY = ready;
        // ------------------------------------

            createHolographicMaterial,
            createEnergyShieldMaterial,
            createLiquidMaterial,
            createCrystalMaterial,
            createNeonMaterial,
            createGlitchMaterial,
            createPortalMaterial,
            createPlasmaMaterial,
            updateMaterialUniforms
        } from '../lib/fx/three/jazer-materials.js';
        import '../lib/engine/jazer-navigation.js';
        window.THREE = THREE;
        const canvas = document.getElementById('c');

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.01);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 10);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
        pointLight2.position.set(-5, 5, -5);
        scene.add(pointLight2);

        // Create materials
        const materials = [
            {
                name: 'HOLOGRAPHIC',
                material: createHolographicMaterial(THREE, {
                    color: new THREE.Color(0x00ffff),
                    fresnelPower: 2.0,
                    scanlineSpeed: 2.0,
                    glitchAmount: 0.1
                }),
                geometry: 'torus'
            },
            {
                name: 'ENERGY SHIELD',
                material: createEnergyShieldMaterial(THREE, {
                    color: new THREE.Color(0x00aaff),
                    hexScale: 15.0,
                    pulseSpeed: 2.0
                }),
                geometry: 'sphere'
            },
            {
                name: 'LIQUID FLOW',
                material: createLiquidMaterial(THREE, {
                    color: new THREE.Color(0x1a4d7a),
                    flowSpeed: 0.5,
                    distortionScale: 2.0
                }),
                geometry: 'torus'
            },
            {
                name: 'CRYSTAL GEM',
                material: createCrystalMaterial(THREE, {
                    color: new THREE.Color(0xff00ff),
                    refractPower: 1.0
                }),
                geometry: 'octahedron'
            },
            {
                name: 'NEON TUBING',
                material: createNeonMaterial(THREE, {
                    color: new THREE.Color(0x00ff88),
                    glowIntensity: 3.0,
                    pulseSpeed: 2.0
                }),
                geometry: 'torusKnot'
            },
            {
                name: 'GLITCH CORRUPTION',
                material: createGlitchMaterial(THREE, {
                    color: new THREE.Color(0xff00ff),
                    glitchIntensity: 0.5
                }),
                geometry: 'box'
            },
            {
                name: 'PORTAL VORTEX',
                material: createPortalMaterial(THREE, {
                    color1: new THREE.Color(0xff0055),
                    color2: new THREE.Color(0x00f5ff),
                    rotationSpeed: 1.0
                }),
                geometry: 'plane'
            },
            {
                name: 'PLASMA',
                material: createPlasmaMaterial(THREE, {
                    speed: 1.0,
                    scale: 2.0
                }),
                geometry: 'sphere'
            }
        ];

        let currentMaterialIndex = 0;
        let mesh;

        // Create geometries
        const geometries = {
            sphere: new THREE.SphereGeometry(3, 64, 64),
            box: new THREE.BoxGeometry(4, 4, 4),
            torus: new THREE.TorusGeometry(3, 1, 32, 100),
            torusKnot: new THREE.TorusKnotGeometry(2, 0.6, 100, 16),
            octahedron: new THREE.OctahedronGeometry(3, 2),
            plane: new THREE.PlaneGeometry(6, 6, 1, 1)
        };

        // Initialize first material
        function setMaterial(index) {
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            }

            const mat = materials[index];
            const geometry = geometries[mat.geometry];

            mesh = new THREE.Mesh(geometry, mat.material);
            scene.add(mesh);

            document.getElementById('materialName').textContent = mat.name;
            document.getElementById('materialIndex').textContent = index + 1;
        }

        setMaterial(0);

        // Click to cycle materials
        canvas.addEventListener('click', () => {
            currentMaterialIndex = (currentMaterialIndex + 1) % materials.length;
            setMaterial(currentMaterialIndex);
        });

        // Particles for atmosphere
        const particleCount = 2000;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleColors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 100;
            particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 100;

            const color = new THREE.Color();
            color.setHSL(Math.random(), 0.8, 0.6);
            particleColors[i * 3] = color.r;
            particleColors[i * 3 + 1] = color.g;
            particleColors[i * 3 + 2] = color.b;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
        const groundMaterial = new THREE.MeshBasicMaterial({
            color: 0x001122,
            transparent: true,
            opacity: 0.3,
            wireframe: true
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -5;
        scene.add(ground);

        // Animation
        let time = 0;
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;

            time += deltaTime;

            // Update current material
            const currentMat = materials[currentMaterialIndex];
            updateMaterialUniforms(currentMat.material, deltaTime);

            // Rotate mesh
            if (mesh) {
                if (currentMat.geometry === 'plane') {
                    // Portal faces camera
                    mesh.lookAt(camera.position);
                } else {
                    mesh.rotation.x = time * 0.3;
                    mesh.rotation.y = time * 0.5;
                }

                // Floating animation
                mesh.position.y = Math.sin(time) * 0.5;
            }

            // Rotate particles slowly
            particles.rotation.y = time * 0.05;

            // Animate camera around object
            const radius = 10;
            camera.position.x = Math.cos(time * 0.3) * radius;
            camera.position.z = Math.sin(time * 0.3) * radius;
            camera.position.y = 2 + Math.sin(time * 0.5) * 2;
            camera.lookAt(mesh.position);

            // Animate lights
            pointLight1.position.x = Math.cos(time) * 10;
            pointLight1.position.z = Math.sin(time) * 10;
            pointLight2.position.x = Math.cos(time + Math.PI) * 10;
            pointLight2.position.z = Math.sin(time + Math.PI) * 10;

            // Special case: Energy shield impact simulation
            if (currentMat.name === 'ENERGY SHIELD' && Math.random() > 0.98) {
                const shield = currentMat.material;
                if (shield.uniforms.uImpactPoint && shield.uniforms.uImpactTime) {
                    // Random impact point on sphere
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    shield.uniforms.uImpactPoint.value.set(
                        Math.sin(phi) * Math.cos(theta) * 3,
                        Math.sin(phi) * Math.sin(theta) * 3,
                        Math.cos(phi) * 3
                    );
                    shield.uniforms.uImpactTime.value = time;
                }
            }

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>
